/* File: object2.c */

/* Purpose: Object code, part 2 */

/*
 * Copyright (c) 1989 James E. Wilson, Robert A. Koeneke
 *
 * This software may be copied and distributed for educational, research, and
 * not for profit purposes provided that this copyright and statement are
 * included in all such copies.
 */

#include "angband.h"

/*
 * Calculate the player's total inventory weight.
 */
s32b calc_total_weight(void)
{
	s32b total = 0;
	for_inventory(p_ptr, o_ptr, 0, INVEN_TOTAL);
	{
		total += o_ptr->weight * o_ptr->number;
	}
	end_inventory();

	return total;
}







/*
 * Known is true when the "attributes" of an object are "known".
 * These include tohit, todam, toac, cost, and pval (charges).
 *
 * Note that "knowing" an object gives you everything that an "awareness"
 * gives you, and much more.  In fact, the player is always "aware" of any
 * item of which he has full "knowledge".
 *
 * But having full knowledge of, say, one "wand of wonder", does not, by
 * itself, give you knowledge, or even awareness, of other "wands of wonder".
 * It happens that most "identify" routines (including "buying from a shop")
 * will make the player "aware" of the object as well as fully "know" it.
 *
 * This routine also removes any inscriptions generated by "feelings".
 */
void object_known(object_type *o_ptr)
{

	/* No Sensing */
	o_ptr->sense = SENSE_NONE;

	/* Clear the "Felt" info */
	o_ptr->ident &= ~(IDENT_SENSE);

	/* Clear the "Empty" info */
	o_ptr->ident &= ~(IDENT_EMPTY);

	/* Now we know about the item */
	o_ptr->ident |= (IDENT_KNOWN);

	if (o_ptr->artifact_id)
		a_info[o_ptr->artifact_id].known = TRUE;
}

/*
 * The player is now aware of the effects of the given object.
 */
void object_aware(object_type *o_ptr)
{

	call_lua("set_aware", "(O)", "", o_ptr);
}

/*
 * Make player forget the effects of the given object.
 */
void object_unaware(object_type *o_ptr)
{

	call_lua("set_aware", "(O,b)", "", o_ptr, TRUE);
}

/*
 * Is the player aware of the effects of the given object?
 */
bool object_aware_p(object_type *o_ptr)
{
	bool ret;

	call_lua("is_aware", "(O)", "b", o_ptr, &ret);

	return ret;
}

/*
 * Something has been "sampled"
 */
void object_tried(object_type *o_ptr)
{
	call_lua("set_tried", "(O)", "", o_ptr);
}

/*
 * Has this object type been "sampled"?
 */
bool object_tried_p(object_type *o_ptr)
{
	bool ret;
	call_lua("is_tried", "(O)", "b", o_ptr, &ret);

	return ret;
}


/*
 * Return the "real" price of a "known" item, not including discounts
 *
 * Wand and staffs get cost for each charge
 *
 * Armor is worth an extra 100 gold per bonus point to armor class.
 *
 * Weapons are worth an extra 100 gold per bonus point (AC,TH,TD).
 *
 * Missiles are only worth 5 gold per bonus point, since they
 * usually appear in groups of 20, and we want the player to get
 * the same amount of cash for any "equivalent" item.  Note that
 * missiles never have any of the "pval" flags, and in fact, they
 * only have a few of the available flags, primarily of the "slay"
 * and "brand" and "ignore" variety.
 *
 * Armor with a negative armor bonus is worthless.
 * Weapons with negative hit+damage bonuses are worthless.
 *
 * Every wearable item with a "pval" bonus is worth extra (see below).
 */
s32b object_value_real(object_type *o_ptr)
{
	s32b value;

	object_kind *k_ptr = &k_info[o_ptr->k_idx];

	/* Base cost */
	value = k_ptr->cost;

	if (has_flag(o_ptr, FLAG_TEMPORARY)) return (0L);

	/* Artifact */
	if (o_ptr->artifact_id)
	{
		artifact_type *a_ptr = &a_info[o_ptr->artifact_id];

		/* Hack -- Use the artifact cost instead */
		value = a_ptr->cost;
	}

	/* Ego-Item */
	else if (o_ptr->ego_id[0])
	{
		s32b base_value = value;
		s32b i;

		value = 0;

		for (i = 0; i < MAX_EGO_PER_OBJ; i++)
		{
			ego_item_type *e_ptr = &e_info[o_ptr->ego_id[i]];

			/* Hack -- Reward the ego-item with a bonus */
			value += e_ptr->value_add;
			base_value = base_value * (100 + e_ptr->base_value_pct) / 100;
		}

		value += base_value;
	}

	if (process_hooks_ret(HOOK_OBJECT_VALUE, "d", "(O, d)", o_ptr,
						  value))
		value = process_hooks_return[0].num;

	/* Return the value */
	return (value);
}


/*
 * Return the price of an item including plusses (and charges)
 *
 * This function returns the "value" of the given item (qty one)
 *
 * Never notice "unknown" bonuses or properties, including "curses",
 * since that would give the player information he did not have.
 *
 * Note that discounted items stay discounted forever, even if
 * the discount is "forgotten" by the player via memory loss.
 */
s32b object_value(object_type *o_ptr)
{
	s32b value;


	/* Known items -- acquire the actual value */
	if (object_known_p(o_ptr))
	{
		/* Cursed items -- worthless */
		if (cursed_p(o_ptr)) return (0L);

		/* Real value (see above) */
		value = object_value_real(o_ptr);
	}

	/* Unknown items -- acquire a base value */
	else
	{
		/* Hack -- Felt cursed items */
		if ((o_ptr->ident & (IDENT_SENSE)) && cursed_p(o_ptr)) return (0L);

		/* Base value (see above) */
		// DGDGDGDG fix me, make a nice way to get base values
		value = 1;
	}


	/* Apply discount (if any) */
	if (o_ptr->discount) value -= (value * o_ptr->discount / 100L);


	/* Return the final value */
	return (value);
}





/*
 * Determine if an item can "absorb" a second item
 *
 * See "object_absorb()" for the actual "absorption" code.
 *
 * If permitted, we allow wands/staffs (if they are known to have equal
 * charges) and rods (if fully charged) to combine.  They will unstack
 * (if necessary) when they are used.
 *
 * If permitted, we allow weapons/armor to stack, if fully "known".
 *
 * Missiles will combine if both stacks have the same "known" status.
 * This is done to make unidentified stacks of missiles useful.
 *
 * Food, potions, scrolls, and "easy know" items always stack.
 *
 * Chests, and activatable items, never stack (for various reasons).
 */
bool object_similar(object_type *o_ptr, object_type *j_ptr)
{
	s32b i;
	s32b total = o_ptr->number + j_ptr->number;
	s32b similar = TRUE;

	/* Require identical object types */
	if (o_ptr->k_idx != j_ptr->k_idx) similar = FALSE;

	/* Only identified objects can stack */
	/* even this is not enough to stop the user being surprised by
	 * (e.g.) ego items which might have random powers being
	 * different although they look the same. This is in fact
	 * fairly unlikely (having *exactly* the same plusses etc)
	 */
	if (!object_known_p(o_ptr) || !object_known_p(j_ptr)) similar = FALSE;

	/* Beware artifatcs should not combibne with "lesser" thing */
	/* perhaps they should not combine at all? */
	if (artifact_p(o_ptr) != artifact_p(j_ptr)) similar = FALSE;

	/* Do not combine different ego or normal ones */
	if (ego_item_p(o_ptr) != ego_item_p(j_ptr)) similar = FALSE;

	/* stuff to implement in ToME lua hooks
	 * instruments don't stack
	 * check stack option setting for certain kinds of items
	 */

	/* Require identical "turns of light" */
	if (o_ptr->timeout != j_ptr->timeout) similar = FALSE;

	/* Require identical "bonuses" */
	if (o_ptr->to_h != j_ptr->to_h) similar = FALSE;
	if (o_ptr->to_d != j_ptr->to_d) similar = FALSE;
	if (o_ptr->to_a != j_ptr->to_a) similar = FALSE;

	/* Require identical exploding status code */
	if (get_flag(o_ptr, FLAG_EXPLODE) != get_flag(j_ptr, FLAG_EXPLODE)) similar = FALSE;

	/* Require identical "artifact" names */
	if (o_ptr->artifact_id != j_ptr->artifact_id) similar = FALSE;

	/* Random artifacts never stack */
	/*
	  I don't see why these shouldn't stack.
	  -- wilh
	*/
	if (o_ptr->art_name || j_ptr->art_name) similar = FALSE;

	/* Require identical "ego-item" names */
	for (i = 0; i < MAX_EGO_PER_OBJ; i++)
		if (o_ptr->ego_id[i] != j_ptr->ego_id[i]) similar = FALSE;

	/* Hack -- Never stack "powerful" items */
	/*
	  Why?!
	  -- wilh
	*/
	if (o_ptr->xtra1 || j_ptr->xtra1) similar = FALSE;


	/* Require identical "values" */
	if (o_ptr->ac != j_ptr->ac) similar = FALSE;
	if (o_ptr->dd != j_ptr->dd) similar = FALSE;
	if (o_ptr->ds != j_ptr->ds) similar = FALSE;

	/* Identical flags! */
        if (!flag_equal(&o_ptr->flags, &j_ptr->flags))
		similar = FALSE;

	/* Hack -- Require identical "cursed" status */
	if ((o_ptr->ident & (IDENT_CURSED)) != (j_ptr->ident & (IDENT_CURSED))) similar = FALSE;

	/* Hack -- require semi-matching "inscriptions" */
	if (o_ptr->note && j_ptr->note && (o_ptr->note != j_ptr->note)) similar = FALSE;

	/* move the next two checks into game/tome/scripts/objects.lua ? */
	/* Hack -- normally require matching "inscriptions" */
	if (!stack_force_notes && (o_ptr->note != j_ptr->note)) similar = FALSE;

	/* Hack -- normally require matching "discounts" */
	if (!stack_force_costs && (o_ptr->discount != j_ptr->discount)) similar = FALSE;

	/* Maximal "stacking" limit */
	if (total >= MAX_STACK_SIZE) similar = FALSE;

	if (process_hooks_ret(HOOK_OBJECT_SIMILAR, "d", "(O,O,d)", o_ptr, j_ptr, similar))
		return process_hooks_return[0].num;

	return similar;
}


/*
 * Allow one item to "absorb" another, assuming they are similar
 */
void object_absorb(object_type *o_ptr, object_type *j_ptr)
{
	s32b total = o_ptr->number + j_ptr->number;

	/* Add together the item counts */
	o_ptr->number = ((total < MAX_STACK_SIZE) ? total : (MAX_STACK_SIZE - 1));

	/* Probably move most or indeed all of this to ToME code
	   instead of T-engine code */

	/* Hack -- blend "known" status */
	if (object_known_p(j_ptr)) object_known(o_ptr);

	/* Hack -- clear "storebought" if only one has it */
	if (((o_ptr->ident & IDENT_STOREB) || (j_ptr->ident & IDENT_STOREB)) &&
	                (!((o_ptr->ident & IDENT_STOREB) && (j_ptr->ident & IDENT_STOREB))))
	{
		if (j_ptr->ident & IDENT_STOREB) j_ptr->ident &= 0xEF;
		if (o_ptr->ident & IDENT_STOREB) o_ptr->ident &= 0xEF;
	}

	/* Hack -- blend "mental" status */
	if (j_ptr->ident & (IDENT_MENTAL)) o_ptr->ident |= (IDENT_MENTAL);

	/* Hack -- blend "inscriptions" */
	if (j_ptr->note) o_ptr->note = j_ptr->note;

	/* Hack -- could average discounts XXX XXX XXX */
	/* Hack -- save largest discount XXX XXX XXX */
	if (o_ptr->discount < j_ptr->discount) o_ptr->discount = j_ptr->discount;

	process_hooks(HOOK_OBJECT_ABSORB,"(O,O)",o_ptr,j_ptr);
}

/*
 * Unstack objects. We don't do anything clever but modules might want
 * to.  o_ptr is the existing stack (with its original
 * 'number'). q_ptr is initially a duplicate of o_ptr, with 'number'
 * set to the amount the engine wants to unstack.
 */

void object_unabsorb(object_type *o_ptr, object_type *q_ptr) {
	process_hooks(HOOK_OBJECT_UNABSORB,"(O,O)",o_ptr,q_ptr);
}


/*
 * Find the index of the object_kind with the given tval and sval
 */
s16b lookup_kind(s32b tval, s32b sval)
{
	s32b k;

	/* Look for it */
	for (k = 1; k < max_k_idx; k++)
	{
		object_kind *k_ptr = &k_info[k];

		/* Found a match */
		if ((k_ptr->tval == tval) && (k_ptr->sval == sval)) return (k);
	}

	/* Oops */
	if (wizard) msg_format("No object (%d,%d)", tval, sval);

	/* Oops */
	return (0);
}


/*
 * Help determine an "enchantment bonus" for an object.
 *
 * To avoid floating point but still provide a smooth distribution of bonuses,
 * we simply round the results of division in such a way as to "average" the
 * correct floating point value.
 *
 * This function has been changed.  It uses "randnor()" to choose values from
 * a normal distribution, whose mean moves from zero towards the max as the
 * level increases, and whose standard deviation is equal to 1/4 of the max,
 * and whose values are forced to lie between zero and the max, inclusive.
 *
 * Since the "level" rarely passes 100 before Morgoth is dead, it is very
 * rare to get the "full" enchantment on an object, even a deep levels.
 *
 * It is always possible (albeit unlikely) to get the "full" enchantment.
 *
 * A sample distribution of values from "m_bonus(10, N)" is shown below:
 *
 *   N       0     1     2     3     4     5     6     7     8     9    10
 * ---    ----  ----  ----  ----  ----  ----  ----  ----  ----  ----  ----
 *   0   66.37 13.01  9.73  5.47  2.89  1.31  0.72  0.26  0.12  0.09  0.03
 *   8   46.85 24.66 12.13  8.13  4.20  2.30  1.05  0.36  0.19  0.08  0.05
 *  16   30.12 27.62 18.52 10.52  6.34  3.52  1.95  0.90  0.31  0.15  0.05
 *  24   22.44 15.62 30.14 12.92  8.55  5.30  2.39  1.63  0.62  0.28  0.11
 *  32   16.23 11.43 23.01 22.31 11.19  7.18  4.46  2.13  1.20  0.45  0.41
 *  40   10.76  8.91 12.80 29.51 16.00  9.69  5.90  3.43  1.47  0.88  0.65
 *  48    7.28  6.81 10.51 18.27 27.57 11.76  7.85  4.99  2.80  1.22  0.94
 *  56    4.41  4.73  8.52 11.96 24.94 19.78 11.06  7.18  3.68  1.96  1.78
 *  64    2.81  3.07  5.65  9.17 13.01 31.57 13.70  9.30  6.04  3.04  2.64
 *  72    1.87  1.99  3.68  7.15 10.56 20.24 25.78 12.17  7.52  4.42  4.62
 *  80    1.02  1.23  2.78  4.75  8.37 12.04 27.61 18.07 10.28  6.52  7.33
 *  88    0.70  0.57  1.56  3.12  6.34 10.06 15.76 30.46 12.58  8.47 10.38
 *  96    0.27  0.60  1.25  2.28  4.30  7.60 10.77 22.52 22.51 11.37 16.53
 * 104    0.22  0.42  0.77  1.36  2.62  5.33  8.93 13.05 29.54 15.23 22.53
 * 112    0.15  0.20  0.56  0.87  2.00  3.83  6.86 10.06 17.89 27.31 30.27
 * 120    0.03  0.11  0.31  0.46  1.31  2.48  4.60  7.78 11.67 25.53 45.72
 * 128    0.02  0.01  0.13  0.33  0.83  1.41  3.24  6.17  9.57 14.22 64.07
 */
s16b m_bonus(s32b max, s32b level)
{
	s32b bonus, stand, extra, value;


	/* Paranoia -- enforce maximal "level" */
	if (level > MAX_DEPTH - 1) level = MAX_DEPTH - 1;


	/* The "bonus" moves towards the max */
	bonus = ((max * level) / MAX_DEPTH);

	/* Hack -- determine fraction of error */
	extra = ((max * level) % MAX_DEPTH);

	/* Hack -- simulate floating point computations */
	if (rand_int(MAX_DEPTH) < extra) bonus++;


	/* The "stand" is equal to one quarter of the max */
	stand = (max / 4);

	/* Hack -- determine fraction of error */
	extra = (max % 4);

	/* Hack -- simulate floating point computations */
	if (rand_int(4) < extra) stand++;


	/* Choose an "interesting" value */
	value = randnor(bonus, stand);

	/* Enforce the minimum value */
	if (value < 0) return (0);

	/* Enforce the maximum value */
	if (value > max) return (max);

	/* Result */
	return (value);
}


/*
 * Cheat -- describe a created object for the user
 */
static void object_mention(object_type *o_ptr)
{
	char o_name[80];

	/* Describe */
	object_desc_store(o_name, o_ptr, FALSE, 0);

	/* Artifact */
	if (artifact_p(o_ptr))
	{
		/* Silly message */
		msg_format("Artifact (%s)", o_name);
	}

	/* Random Artifact */
	else if (o_ptr->art_name)
	{
		msg_print("Random artifact");
	}

	/* Ego-item */
	else if (ego_item_p(o_ptr))
	{
		/* Silly message */
		msg_format("Ego-item (%s)", o_name);
	}

	/* Normal item */
	else
	{
		/* Silly message */
		msg_format("Object (%s)", o_name);
	}
}


/*
 * Apply special make code
 */
static void invoke_on_make(flags_type *flags, object_type *o_ptr, s32b power)
{
	if (flag_exists(flags, FLAG_ON_MAKE))
	{
		open_lua_functions_registry(flag_get(flags, FLAG_ON_MAKE), flag_get2(flags, FLAG_ON_MAKE));
		call_lua(NULL, "(O,d)", "", o_ptr, power);
		close_lua_functions_registry();
	}
}

/*
 * Apply special make code
 */
static void invoke_on_make_all(object_type *o_ptr, s32b power)
{
	call_lua("objects_on_make_all", "(O,d)", "", o_ptr, power);
}

/*
 * Apply special make code
 */
static void invoke_on_make_all_pre(object_type *o_ptr, s32b power)
{
	call_lua("objects_on_make_all_pre", "(O,d)", "", o_ptr, power);
}

/*
 * Complete the "creation" of an object by applying "magic" to the item
 *
 * This includes not only rolling for random bonuses, but also putting the
 * finishing touches on ego-items and artifacts, giving charges to wands and
 * staffs, giving fuel to lites, and placing traps on chests.
 *
 * In particular, note that "Instant Artifacts", if "created" by an external
 * routine, must pass through this function to complete the actual creation.
 *
 * The base "chance" of the item being "good" increases with the "level"
 * parameter, which is usually derived from the dungeon level, being equal
 * to the level plus 10, up to a maximum of 75.  If "good" is true, then
 * the object is guaranteed to be "good".  If an object is "good", then
 * the chance that the object will be "great" (ego-item or artifact), also
 * increases with the "level", being equal to half the level, plus 5, up to
 * a maximum of 20.  If "great" is true, then the object is guaranteed to be
 * "great".  At dungeon level 65 and below, 15/100 objects are "great".
 *
 * If the object is not "good", there is a chance it will be "cursed", and
 * if it is "cursed", there is a chance it will be "broken".  These chances
 * are related to the "good" / "great" chances above.
 *
 * Otherwise "normal" rings and amulets will be "good" half the time and
 * "cursed" half the time, unless the ring/amulet is always good or cursed.
 *
 * If "okay" is true, and the object is going to be "great", then there is
 * a chance that an artifact will be created.  This is true even if both the
 * "good" and "great" arguments are false.  As a total hack, if "great" is
 * true, then the item gets 3 extra "attempts" to become an artifact.
 */
s32b hack_apply_magic_power = 0;
void apply_magic(object_type *o_ptr, s32b lev, bool okay, bool good, bool great)
{
	s32b i, power;
	object_kind *k_ptr = &k_info[o_ptr->k_idx];

	/* Uses level */
	flags_mbonus_level = lev;

	call_lua("objects_get_power_level", "(O,d,b,b,b)", "d", o_ptr, lev, okay, good, great, &power);

	/* Initialize books */
	if (has_flag(o_ptr, FLAG_GET_BOOK_SPELLS))
	{
		call_lua("setup_object_spells", "(O,d)", "", o_ptr, get_flag(o_ptr, FLAG_GET_BOOK_SPELLS));
	}

	/* No need to touch normal artifacts */
	if ((has_flag(k_ptr, FLAG_NORM_ART)))
	{
		/* Ahah! we tried to trick us !! */
		if (k_ptr->artifact ||
		                (((has_flag(k_ptr, FLAG_SPECIAL_GENE))) &&
		                 (!k_allow_special[o_ptr->k_idx])))
		{
			object_prep(o_ptr, lookup_kind(get_flag(k_ptr, FLAG_NORM_ART), flag_get2(&k_ptr->flags, FLAG_NORM_ART)));
			if (wizard) msg_print("We've been tricked!");
		}
		else
		{
			k_ptr->artifact = TRUE;

			if (cheat_peek || p_ptr->precognition) object_mention(o_ptr);
		}

		/* Reset to default */
		flags_mbonus_level = -1;
		return;
	}

	/* Mega hack */
	if (hack_apply_magic_power)
	{
		if (hack_apply_magic_power == -99)
			power = 0;
		else
			power = hack_apply_magic_power;
	}
	hack_apply_magic_power = 0;

	o_ptr->elevel = 1;
	o_ptr->exp = 0;

	/* Special make code */
	invoke_on_make(&k_ptr->flags, o_ptr, power);

	/* Generic on make for all items */
	invoke_on_make_all_pre(o_ptr, power);

	/* Hack -- analyze artifacts */
	if (o_ptr->artifact_id)
	{
		artifact_type *a_ptr = &a_info[o_ptr->artifact_id];

		/* Hack -- Mark the artifact as "created" */
		a_ptr->cur_num = 1;

		/* Extract the other fields */
		o_ptr->ac = a_ptr->ac;
		o_ptr->dd = a_ptr->dd;
		o_ptr->ds = a_ptr->ds;
		o_ptr->to_a = a_ptr->to_a;
		o_ptr->to_h = a_ptr->to_h;
		o_ptr->to_d = a_ptr->to_d;
		o_ptr->weight = a_ptr->weight;
		o_ptr->number = 1;

                /* Transfer flags */
		flag_add(&o_ptr->flags, &a_ptr->flags);

		/* Mega-Hack -- increase the rating */
		rating += 10;

		/* Mega-Hack -- increase the rating again */
		if (a_ptr->cost > 50000L) rating += 10;

		/* Set the good item flag */
		good_item_flag = TRUE;

		/* Cheat -- peek at the item */
		if ((cheat_peek) || (p_ptr->precognition)) object_mention(o_ptr);

		/* Special make code */
		invoke_on_make(&a_ptr->flags, o_ptr, power);
		invoke_on_make_all(o_ptr, power);

		/* Hack -- extract the "cursed" flag */
		if (has_flag(o_ptr, FLAG_CURSED)) o_ptr->ident |= (IDENT_CURSED);

		/* Done */
		/* Reset to default */
		flags_mbonus_level = -1;
		return;
	}


	if (o_ptr->art_name) rating += 40;

	/* Analyze ego-items */
	else
	{
		ego_item_type *e_ptr;
		s32b j;
		s16b e_idx;
		bool did_ego = FALSE;

		for (i = 0; i < MAX_EGO_PER_OBJ; i++)
		{
			e_idx = o_ptr->ego_id[i];
			if (!e_idx) continue;
			did_ego = TRUE;
			e_ptr = &e_info[e_idx];

			/* Hack -- extra powers */
			for (j = 0; j < MAX_EGO_FLAG_GROUPS; j++)
			{
				/* Rarity check */
				if (magik(e_ptr->rar[j]))
				{
					/* Copy all flags */
					flag_add(&o_ptr->flags, &e_ptr->flags[j]);

					/* Special make code */
					invoke_on_make(&e_ptr->flags[j], o_ptr, power);
				}
			}

			/* Hack -- acquire "cursed" flag */
			if (has_flag(o_ptr, FLAG_CURSED)) o_ptr->ident |= (IDENT_CURSED);

			/* Hack -- obtain bonuses */
			if (e_ptr->max_to_h > 0) o_ptr->to_h += randint(e_ptr->max_to_h);
			if (e_ptr->max_to_h < 0) o_ptr->to_h -= randint( -e_ptr->max_to_h);
			if (e_ptr->max_to_d > 0) o_ptr->to_d += randint(e_ptr->max_to_d);
			if (e_ptr->max_to_d < 0) o_ptr->to_d -= randint( -e_ptr->max_to_d);
			if (e_ptr->max_to_a > 0) o_ptr->to_a += randint(e_ptr->max_to_a);
			if (e_ptr->max_to_a < 0) o_ptr->to_a -= randint( -e_ptr->max_to_a);

			/* Hack -- apply rating bonus */
			rating += e_ptr->rating;
		}

		/* Cheat -- describe the item */
		if ((did_ego) && ((cheat_peek) || (p_ptr->precognition))) object_mention(o_ptr);
	}

	/* Generic on make for all items */
	invoke_on_make_all(o_ptr, power);

	/* Examine real objects */
	if (o_ptr->k_idx)
	{
		/* Hack -- acquire "cursed" flag */
		if (has_flag(o_ptr, FLAG_CURSED)) o_ptr->ident |= (IDENT_CURSED);
	}

	/* Reset to default */
	flags_mbonus_level = -1;
}

/*
 * Attempt to make an object (normal or good/great)
 *
 * This routine plays nasty games to generate the "special artifacts".
 *
 * This routine uses "object_level" for the "generation level".
 *
 * We assume that the given object has been "wiped".
 *
 * To Watch: The allocation table caching is heavily relies on
 * an assumption that the SPECIAL_GENE objects should only be created
 * through the forge--object_prep()--apply_magic() sequence and
 * get_obj_num() should never be called for that purpose XXX XXX XXX
 */
object_type* make_object(bool good, bool great, flags_type* theme)
{
	object_type* obj = NULL;

	call_lua("rand_obj.make_object", "(b,b,F)", "O", good, great,
			 theme, &obj);

	return obj;
}

/*
 * Attempt to place an object (normal or good/great) at the given location.
 *
 * This routine plays nasty games to generate the "special artifacts".
 *
 * This routine uses "object_level" for the "generation level".
 *
 * This routine requires a clean floor grid destination.
 */
void place_object(s32b y, s32b x, bool good, bool great, s32b where)
{
	object_type *q_ptr;


	/* Paranoia -- check bounds */
	if (!in_bounds(y, x)) return;

	/* Require clean floor space */
	if (!cave_clean_bold(y, x)) return;


	/* Get local object */
	q_ptr = make_object(good, great, NULL);

	/* Make an object (if possible) */
	if (q_ptr == NULL)
		return;

	if (where == OBJ_FOUND_VAULT)
	{
		q_ptr->found = OBJ_FOUND_VAULT;
		q_ptr->found_aux1 = dungeon_type;
		q_ptr->found_aux2 = level_or_feat(dungeon_type, dun_level);
	}
	else if (where == OBJ_FOUND_FLOOR)
	{
		q_ptr->found = OBJ_FOUND_FLOOR;
		q_ptr->found_aux1 = dungeon_type;
		q_ptr->found_aux2 = level_or_feat(dungeon_type, dun_level);
	}
	else if (where == OBJ_FOUND_SPECIAL)
	{
		q_ptr->found = OBJ_FOUND_SPECIAL;
	}
	else if (where == OBJ_FOUND_RUBBLE)
	{
		q_ptr->found = OBJ_FOUND_RUBBLE;
	}

	/* Object array overflow */
	if (!floor_carry(y, x, q_ptr))
	{
		/* Hack -- Preserve artifacts */
		if (q_ptr->artifact_id)
		{
			a_info[q_ptr->artifact_id].cur_num = 0;
		}
		else if (has_flag(&k_info[q_ptr->k_idx], FLAG_NORM_ART))
		{
			k_info[q_ptr->k_idx].artifact = 0;
		}

		delete_object(q_ptr);
	}
}


/*
 * XXX XXX XXX Do not use these hard-coded values.
 */
#define OBJ_GOLD_LIST   480     /* First "gold" entry */
#define MAX_GOLD        18      /* Number of "gold" entries */

flags_type *gold_list = 0;
static void init_gold_list()
{
	s32b k;
	s32b i=0;

	/* Create a list of TV_GOLD drops */
	gold_list = flag_new(0);

	/* Look for TV_GOLD */
	for (k = 1; k < max_k_idx; k++)
	{
		object_kind *k_ptr = &k_info[k];

		/* Found a match */
		if (has_flag(k_ptr, FLAG_GOLD_VALUE))
		{
			flag_set(gold_list, i, k);
			i++;
		}
	}
}

/*
 * Make a treasure object
 *
 * The location must be a legal, clean, floor grid.
 */
bool make_gold(object_type *j_ptr)
{
	s32b i;
	s32b k_idx;

	s32b base;

	/* First time set up the list of TV_GOLD svals */
	if (!gold_list) init_gold_list();

	/* Hack -- Pick a Treasure variety */
	i = ((randint(object_level + 2) + 2) / 2) - 1;

	/* Apply "extra" magic */
	if (rand_int(GREAT_OBJ) == 0)
	{
		i += randint(object_level + 1);
	}

	/* Hack -- Creeping Coins only generate "themselves" */
	if (coin_type) i = coin_type;

	/* Do not create "illegal" Treasure Types */
	if (i > flag_max_key(gold_list)) i = flag_max_key(gold_list);

	/* lookup the i'th SV from gold_list and use that */
	k_idx = flag_get(gold_list, i);

	/* Prepare a gold object */
	object_prep(j_ptr, k_idx);

	/* Base coin cost from flag */
	base = flag_get(&k_info[k_idx].flags,FLAG_GOLD_VALUE);

	/* Determine how much the treasure is "worth" (maybe use getter.random instead?) */
	flag_set(&j_ptr->flags, FLAG_GOLD_VALUE, (base + randint(base)));

	/* Success */
	return (TRUE);
}


/*
 * Places a treasure (Gold or Gems) at given location
 *
 * The location must be a legal, clean, floor grid.
 */
void place_gold(s32b y, s32b x)
{
	object_type *q_ptr;

	/* Paranoia -- check bounds */
	if (!in_bounds(y, x)) return;

	/* Require clean floor space */
	if (!cave_clean_bold(y, x)) return;


	/* Get local object */
	q_ptr = new_object();

	/* Make some gold */
	if (!make_gold(q_ptr)) return;

	if (!floor_carry(y, x, q_ptr))
	delete_object(q_ptr);
}


/*
 * Let an object fall to the ground at or near a location.
 *
 * The initial location is assumed to be "in_bounds()".
 *
 * This function takes a parameter "chance".  This is the percentage
 * chance that the item will "disappear" instead of drop.  If the object
 * has been thrown, then this is the chance of disappearance on contact.
 *
 * Hack -- this function uses "chance" to determine if it should produce
 * some form of "description" of the drop event (under the player).
 *
 * We check several locations to see if we can find a location at which
 * the object can combine, stack, or be placed.  Artifacts will try very
 * hard to be placed, including "teleporting" to a useful grid if needed.
 */
s16b drop_near(object_type *j_ptr, s32b chance, s32b y, s32b x)
{
	s32b i, k, d, s;

	s32b bs, bn;
	s32b by, bx;
	s32b dy, dx;
	s32b ty, tx;

	s16b o_idx = 0;

	cave_type *c_ptr;

	char o_name[80];

	bool flag = FALSE;

	bool plural = FALSE;


	/* Extract plural */
	if (j_ptr->number != 1) plural = TRUE;

	/* Describe object */
	object_desc(o_name, j_ptr, FALSE, 0);


	/* Handle normal "breakage" */
	if (!(j_ptr->art_name || artifact_p(j_ptr)) && (rand_int(100) < chance))
	{
		/* Message */
		msg_format("The %s disappear%s.",
		           o_name, (plural ? "" : "s"));

		/* Debug */
		if (wizard) msg_print("(breakage)");

		delete_object(j_ptr);

		/* Failure */
		return (0);
	}


	/* Score */
	bs = -1;

	/* Picker */
	bn = 0;

	/* Default */
	by = y;
	bx = x;

	/* Scan local grids */
	for (dy = -3; dy <= 3; dy++)
	{
		/* Scan local grids */
		for (dx = -3; dx <= 3; dx++)
		{
			bool comb = FALSE;

			/* Calculate actual distance */
			d = (dy * dy) + (dx * dx);

			/* Ignore distant grids */
			if (d > 10) continue;

			/* Location */
			ty = y + dy;
			tx = x + dx;

			/* Skip illegal grids */
			if (!in_bounds(ty, tx)) continue;

			/* Require line of sight */
			if (!los(y, x, ty, tx)) continue;

			/* Obtain grid */
			c_ptr = &cave[ty][tx];

			/* Require floor space (or shallow terrain) -KMW- */
			if (!has_flag(&f_info[c_ptr->feat], FLAG_FLOOR)) continue;

			/* No traps */
			if (flag_used(&c_ptr->activations)) continue;

			/* No objects */
			k = 0;

			/* Scan objects in that grid */
			for_inventory_slot(&c_ptr->inventory, o_ptr);
			{
				/* Check for possible combination */
				if (object_similar(o_ptr, j_ptr)) comb = TRUE;

				/* Count objects */
				k++;
			}
			end_inventory_slot();

			/* Add new object */
			if (!comb) k++;

			/* Paranoia */
			if (k >= inventory_limit_inven(&c_ptr->inventory)) continue;

			/* Calculate score */
			s = 1000 - (d + k * 5);

			/* Skip bad values */
			if (s < bs) continue;

			/* New best value */
			if (s > bs) bn = 0;

			/* Apply the randomizer to equivalent values */
			if ((++bn >= 2) && (rand_int(bn) != 0)) continue;

			/* Keep score */
			bs = s;

			/* Track it */
			by = ty;
			bx = tx;

			/* Okay */
			flag = TRUE;
		}
	}


	/* Handle lack of space */
	if (!flag && !(artifact_p(j_ptr) || j_ptr->art_name))
	{
		/* Message */
		msg_format("The %s disappear%s.",
		           o_name, (plural ? "" : "s"));

		/* Debug */
		if (wizard) msg_print("(no floor space)");

		delete_object(j_ptr);

		/* Failure */
		return (0);
	}


	/* Find a grid */
	for (i = 0; !flag; i++)
	{
		/* Bounce around */
		if (i < 1000)
		{
			ty = rand_spread(by, 1);
			tx = rand_spread(bx, 1);
		}

		/* Random locations */
		else
		{
			ty = rand_int(cur_hgt);
			tx = rand_int(cur_wid);
		}

		/* Grid */
		c_ptr = &cave[ty][tx];

		/* Require floor space */
		if (!has_flag(&f_info[c_ptr->feat], FLAG_FLOOR) || has_flag(&f_info[c_ptr->feat], FLAG_NO_WALK)) continue;

		/* Bounce to that location */
		by = ty;
		bx = tx;

		/* Require floor space */
		if (!cave_clean_bold(by, bx)) continue;

		/* Okay */
		flag = TRUE;
	}

	j_ptr->iy         = by;
	j_ptr->ix         = bx;
	j_ptr->held_m_idx = 0;

	/* Grid */
	c_ptr = &cave[by][bx];

	/* Carry */
	o_idx = inven_carry_inven(&c_ptr->inventory, j_ptr, FALSE);

	/*
	 * j_ptr might have been merged into an existing object and then
	 * deleted, so re-get the object.
	 */
	j_ptr = get_object(item_slot_to_item(o_idx));

	/* Note the spot */
	note_spot(by, bx);

	/* Draw the spot */
	lite_spot(by, bx);

	/* Mega-Hack -- no message if "dropped" by player */
	/* Message when an object falls under the player */
	if (chance && (by == p_ptr->py) && (bx == p_ptr->px))
	{
		msg_print("You feel something roll beneath your feet.");
		/* Sound */
		sound(SOUND_DROP);
	}

	process_hooks(HOOK_DROPPED_NEAR, "(O,b,d,d,d,d)", j_ptr, chance,
				  y, x, by, bx);

	/* XXX XXX XXX */

	/* Result */
	return (o_idx);
}




/*
 * Scatter some "great" objects near the player
 */
void acquirement(s32b y1, s32b x1, s32b num, bool great, bool known)
{
	object_type *i_ptr;

	/* Acquirement */
	while (num--)
	{
		/* Get local object */
		i_ptr = make_object(TRUE, great, NULL);

		/* Make a good (or great) object (if possible) */
		if (i_ptr == NULL)
			return;

		if (known)
		{
			object_aware(i_ptr);
			object_known(i_ptr);
		}

		/* Drop the object */
		drop_near(i_ptr, -1, y1, x1);
	}
}


/*
 * Describe an item in the inventory.
 */
void item_describe(s32b item)
{
	object_type *o_ptr = get_object(item);
	char o_name[80];

	if (!o_ptr) return;

	/* Get a description */
	object_desc(o_name, o_ptr, TRUE, 3);

	/* Print a message */
	msg_format("%s %s.", (item < 0) ? "You see":"You have", o_name);
}


/*
 * Increase the "number" of an item in the inventory
 */
void item_increase(s32b item, s32b num)
{
	object_type *o_ptr = get_object(item);

	if (!o_ptr) return;

	/* Apply */
	num += o_ptr->number;

	/* Bounds check */
	if (num > 255) num = 255;
	else if (num < 0) num = 0;

	/* Un-apply */
	num -= o_ptr->number;

	/* Change the number and weight */
	if (num)
	{
		/* Add the number */
		o_ptr->number += num;

		if (item >= 0)
		{
			/* Recalculate bonuses */
			p_ptr->update |= (PU_BONUS);

			/* Recalculate mana XXX */
			p_ptr->update |= (PU_MANA);

			/* Combine the pack */
			p_ptr->notice |= (PN_COMBINE);

			/* Window stuff */
			flag_bool(&p_ptr->window, FLAG_PW_INVEN);
			flag_bool(&p_ptr->window, FLAG_PW_EQUIP);
		}
	}
}


/*
 * Erase an inventory slot if it has no more items
 */
bool item_optimize(s32b item)
{
	object_type *o_ptr = get_object(item);

	/* Only optimize real items */
	if (!o_ptr) return (FALSE);

	/* Only optimize empty items */
	if (o_ptr->number) return (FALSE);

	call_lua("__core_objects.item_optimize", "(d,O)", "", item, o_ptr);

	return (TRUE);
}

/*
 * Check if we have space for an item in the pack without overflow
 */
bool inven_carry_okay(object_type *o_ptr)
{
	if (has_flag(o_ptr, FLAG_GOLD_VALUE)) return FALSE;

	/* Empty slot? */
	if (inventory_limit(INVEN_INVEN) > flag_max_key(get_inven(p_ptr, INVEN_INVEN))) return (TRUE);

	/* Similar slot? */
	for_inventory(p_ptr, j_ptr, INVEN_INVEN, INVEN_PACK);
	{
		/* Check if the two items can be combined */
		if (object_similar(j_ptr, o_ptr)) return (TRUE);
	}
	end_inventory();

	/* Nope */
	return (FALSE);
} /* inven_carry_okay() */

/*
 * Add an item to the player's inventory.  Uses inven_carry_inven()
 * to do the real work.
 */
s16b inven_carry(object_type *o_ptr, bool final)
{
	s32b slot;
	object_type *copy_ptr;

	/* Clean out unused fields */
	o_ptr->iy = o_ptr->ix = 0;
	o_ptr->next_o_idx = 0;
	o_ptr->held_m_idx = 0;

	/* Make a copy in case we need it */
	copy_ptr = object_dup(o_ptr);

	slot = inven_carry_inven(get_inven(p_ptr, INVEN_INVEN), o_ptr, final);
	if (slot == -1)
	{
		drop_near(copy_ptr, 0, p_ptr->py, p_ptr->px);
	}
	else
	{
		/* Ok we didnt needed the copy */
		object_wipe(copy_ptr);
		delete_object(copy_ptr);
	}
	return slot;
} /* inven_carry() */

/*
 * Add an item to ANY inventory, and return the slot used.  This is
 * used for manipulating monster, player, floor, and store inventory,
 * and probably more; use inven_carry() for just the player's
 * inventory.
 *
 * If the new item can combine with an existing item in the inventory,
 * it will do so, using "object_similar()" and "object_absorb()", otherwise,
 * the item will be placed into the "proper" location in the inventory.
 *
 * This function can be used to "over-fill" the player's pack, but only
 * once, and such an action must trigger the "overflow" code immediately.
 * Note that when the pack is being "over-filled", the new item must be
 * placed into the "overflow" slot, and the "overflow" must take place
 * before the pack is reordered, but (optionally) after the pack is
 * combined.  This may be tricky.  See "dungeon.c" for info.
 *
 * Note that this code must remove any location/stack information
 * from the object once it is placed into the inventory.
 *
 * The "final" flag tells this function to bypass the "combine"
 * and "reorder" code until later.
 */
s16b inven_carry_inven(flags_type *inven, object_type *o_ptr, bool final)
{
	s32b i, j, k;
	object_type *j_ptr;

	/* Not final */
	if (!final)
	{
		/* Check for combining */
		for_inventory_slot(inven, j_ptr);
		{
			/* Check if the two items can be combined */
			if (object_similar(j_ptr, o_ptr))
			{
				/* Combine the items */
				object_absorb(j_ptr, o_ptr);
				delete_object(o_ptr);

				/* Recalculate bonuses */
				p_ptr->update |= (PU_BONUS);

				/* Window stuff */
				flag_bool(&p_ptr->window, FLAG_PW_INVEN);

				/* Success */
				return compute_slot(INVEN_INVEN, item_nb);
			}
		}
		end_inventory_slot();
	}

	/*
	 * Object didn't combine with something in the inventory, and all
	 * inventory slots are already used.
	 */
	if (!final && (flag_used(inven) > inventory_limit_inven(inven)))
	{
		delete_object(o_ptr);
		return ( -1);
	}

	/* The empty slot is ALWAYS the last slot */
	/* Use that slot */
	i = flag_max_key(inven) + 1;

	/* Hack -- pre-reorder the pack */
	if (!final && (i < inventory_limit_inven(inven)))
	{
		s32b o_value, j_value;

		/* Get the "value" of the item */
		o_value = object_value(o_ptr);

		/* Scan every occupied slot */
		for (j = 1; j <= flag_max_key(inven); j++)
		{
			j_ptr = flag_get_obj(inven, j);

			/* Use empty slots, should not happen! */
			if (!j_ptr) break;

			/* Objects sort by decreasing type */
			if (o_ptr->tval > j_ptr->tval) break;
			if (o_ptr->tval < j_ptr->tval) continue;

			/* Non-aware (flavored) items always come last */
			if (!object_aware_p(o_ptr)) continue;
			if (!object_aware_p(j_ptr)) break;

			/* Objects sort by increasing sval */
			if (o_ptr->sval < j_ptr->sval) break;
			if (o_ptr->sval > j_ptr->sval) continue;

			/* Unidentified objects always come last */
			if (!object_known_p(o_ptr)) continue;
			if (!object_known_p(j_ptr)) break;

			/* Determine the "value" of the pack item */
			j_value = object_value(j_ptr);

			/* Objects sort by decreasing value */
			if (o_value > j_value) break;
			if (o_value < j_value) continue;
		}

		/* Use that slot */
		i = j;

		/* Slide objects */
		for (k = flag_used(inven) - 1; k >= i; k--)
		{
			/* Slide the item */
			j_ptr = flag_get_obj(inven, k);
			flag_remove_zap(inven, k);
			flag_set_obj(inven, k + 1, j_ptr);
		}
		/* Empty the place, but do not free memor yas the object still exists in the next slot */
		flag_remove_zap(inven, i);
	}

	/* Acquire the item */
	flag_set_obj(inven, i, o_ptr);

	/* DGDGDG - inven_cnt obsolete ? JMLB */
	/* Count the items */
	inven_cnt++;

	/* DGDGDG - only if player inventory (it isn't always) */
	/* Recalculate bonuses */
	p_ptr->update |= (PU_BONUS);

	/* Combine and Reorder pack */
	p_ptr->notice |= (PN_COMBINE | PN_REORDER);

	/* Window stuff */
	flag_bool(&p_ptr->window, FLAG_PW_INVEN);

	/* Return the slot */
	return compute_slot(INVEN_INVEN, i);
} /* inven_carry_inven() */

/*
 * Take off (some of) a non-cursed equipment item
 *
 * Note that only one item at a time can be wielded per slot.
 *
 * Note that taking off an item when "full" may cause that item
 * to fall to the ground.
 *
 * Return the inventory slot into which the item is placed.
 */
s16b inven_takeoff(s32b item, s32b amt, bool force_drop, bool silent)
{
	s32b slot;
	object_type *q_ptr;
	object_type *o_ptr;
	cptr act;
	char o_name[80];

	/* Get the item to take off */
	o_ptr = get_object(item);

	/* Paranoia */
	if (!o_ptr) return ( -1);
	if (amt <= 0) return ( -1);

	/* Verify */
	if (amt > o_ptr->number) amt = o_ptr->number;

	/* Can we take it off? */
	if (process_hooks(HOOK_TAKEOFF_PRE, "(O,d)", o_ptr, item))
		return(-1);

	/* Tell lua that we have taken it off */

	/* Get local object */
	q_ptr = new_object();

	/* Obtain a local object */
	object_copy(q_ptr, o_ptr);

	/* Modify quantity */
	q_ptr->number = amt;

	/* Describe the object */
	object_desc(o_name, q_ptr, TRUE, 3);

	/* Took off something */
	act = inventory_slot_names[item_slot_to_inven(item)].takeoff;

	/* Modify, Optimize */
	item_increase(item, -amt);
	item_optimize(item);

	if (force_drop)
	{
		drop_near(q_ptr, 0, p_ptr->py, p_ptr->px);
		slot = -1;
	}
	else
	{
		/* Carry the object */
		slot = inven_carry(q_ptr, FALSE);

		/*
		 * q_ptr might have been merged into an existing object and then
		 * deleted, so re-get the object.
		 */
		q_ptr = get_object(item_slot_to_item(slot));
	}

	/* Message */
	if (!silent) msg_format("%s %s (%c).", act, o_name, index_to_label(slot));

	/* Inform scripts that takeoff completed */
	if (slot != -1) process_hooks(HOOK_TAKEOFF_POST, "(O,d,d,d)", q_ptr, item, amt, force_drop);

	/* Return slot */
	return (slot);
}




/*
 * Drop (some of) a non-cursed inventory/equipment item
 *
 * The object will be dropped "near" the current location
 */
s16b inven_drop(s32b item, s32b amt, s32b dy, s32b dx, bool silent)
{
	object_type *q_ptr;
	object_type *o_ptr;
	char        o_name[80];
	s16b        ret = 0;

	/* Access original object */
	o_ptr = get_object(item);

	/* Error check */
	if ((!o_ptr) || (amt <= 0)) return(0);

	/* Not too many */
	if (amt > o_ptr->number) amt = o_ptr->number;

	/* Can we drop? */
	if (process_hooks(HOOK_DROP_PRE, "(O,d)", o_ptr, item))
		return 0;

	/* Take off equipment */
	if (item_slot_to_inven(item) >= INVEN_PACK)
	{
		/* Take off first */
		item = inven_takeoff(item, amt, FALSE, silent);

		/* Access original object */
		if (item < 0) return(0);
		o_ptr = get_object(item);
	}

	if (item > -1)
	{
		/* Get local object */
		q_ptr = new_object();

		/* Obtain local object */
		object_copy(q_ptr, o_ptr);

		/* Modify quantity */
		q_ptr->number = amt;

		/* Possible special handling as we unstack */
		object_unabsorb(o_ptr,q_ptr);

		/* Describe local object */
		object_desc(o_name, q_ptr, TRUE, 3);

		/* Message */
		if (!silent)
			msg_format("You drop %s (%c).", o_name, index_to_label(item));

		/* Drop it near the player */
		ret = drop_near(q_ptr, 0, dy, dx);

		/* Modify, Describe, Optimize */
		item_increase(item, -amt);
		if (!silent) item_describe(item);
		item_optimize(item);
	}

	if (ret == 0)
		return 0;

	/*
	 * Tell the scripts.  Start dealing with the object on the floor
	 * instead of the object in inventory.
	 */
	o_ptr = get_object(ret);
	if (o_ptr)
		process_hooks(HOOK_DROP_POST, "(O,d)", o_ptr, ret);

	return ret;
}



/*
 * Combine items in the pack
 *
 * Note special handling of the "overflow" slot
 */
void combine_pack(void)
{
	s32b i, j, k;
	object_type *j_ptr, *o_ptr;
	bool flag = FALSE;
	flags_type *inven = get_inven(p_ptr, INVEN_INVEN);

	/* Combine the pack (backwards) */
	for (i = 1; i <= flag_max_key(inven); i++)
	{
		/* Get the item */
		o_ptr = get_object_split(INVEN_INVEN, i);

		/* Skip empty items */
		if (!o_ptr) continue;

		/* Scan the items above that item */
		for (j = 1; j < i; j++)
		{
			/* Get the item */
			j_ptr = get_object_split(INVEN_INVEN, j);

			/* Skip empty items -- shouldnt happen */
			if (!j_ptr) continue;

			/* Can we drop "o_ptr" onto "j_ptr"? */
			if (object_similar(j_ptr, o_ptr))
			{
				/* Take note */
				flag = TRUE;

				/* Add together the item counts */
				object_absorb(j_ptr, o_ptr);

				/* One object is gone */
				inven_cnt--;

				/* Erase the slot */
				flag_remove(inven, i);

				/* Slide everything down */
				for (k = i; k <= flag_max_key(inven) - 1; k++)
				{
					/* Slide the item */
					object_type *oo_ptr = flag_get_obj(inven, k + 1);
					flag_remove_zap(inven, k + 1);
					flag_set_obj(inven, k, oo_ptr);
				}

				/* Window stuff */
				flag_bool(&p_ptr->window, FLAG_PW_INVEN);

				/* Done */
				break;
			}
		}
	}

	/* Message */
	if (flag) msg_print("You combine some items in your pack.");
}


/*
 * Reorder items in the pack
 *
 * Note special handling of the "overflow" slot
 */
void reorder_pack(void)
{
	s32b i, j, k;
	s32b o_value;
	s32b j_value;
	object_type *q_ptr;
	object_type *j_ptr;
	object_type *o_ptr;
	bool flag = FALSE;
	flags_type *inven = get_inven(p_ptr, INVEN_INVEN);
	s32b max = flag_used(inven);
	/* better to use flag_max_key here instead of flag_used?
	   and change < max to <= max below... */

	/* Re-order the pack (forwards) */
	for (i = 1; i < max; i++)
	{
		/* Mega-Hack -- allow "proper" over-flow */
		/* If we are due to overflow (pack too full) then don't
		   re-order the last item: we want to overflow the thing we
		   just picked up/removed/whatever, that makes most sense */
		if ((i == inventory_limit(INVEN_INVEN)+1) && (max == inventory_limit(INVEN_INVEN)+2))
			break;

		/* Get the item */
		o_ptr = get_object_split(INVEN_INVEN, i);

		/* Skip empty slots */
		if (!o_ptr) continue;

		/* Get the "value" of the item */
		o_value = object_value(o_ptr);

		/* Scan every occupied slot */
		for (j = 1; j < max; j++)
		{
			/* Get the item already there */
			j_ptr = get_object_split(INVEN_INVEN, j);

			/* Use empty slots */
			if (!j_ptr) break;

			/* Objects sort by decreasing type */
			if (o_ptr->tval > j_ptr->tval) break;
			if (o_ptr->tval < j_ptr->tval) continue;

			/* Non-aware (flavored) items always come last */
			if (!object_aware_p(o_ptr)) continue;
			if (!object_aware_p(j_ptr)) break;

			/* Objects sort by increasing sval */
			if (o_ptr->sval < j_ptr->sval) break;
			if (o_ptr->sval > j_ptr->sval) continue;

			/* Unidentified objects always come last */
			if (!object_known_p(o_ptr)) continue;
			if (!object_known_p(j_ptr)) break;

			/* Determine the "value" of the pack item */
			j_value = object_value(j_ptr);

			/* Objects sort by decreasing value */
			if (o_value > j_value) break;
			if (o_value < j_value) continue;
		}

		/* Never move down */
		if (j >= i) continue;

		/* Take note */
		flag = TRUE;

		/* Get local object */
		q_ptr = get_object_split(INVEN_INVEN, i);
		flag_remove_zap(inven, i);

		/* Slide objects */
		for (k = i; k > j; k--)
		{
			/* Slide the item */
			j_ptr = flag_get_obj(inven, k - 1);
			flag_remove_zap(inven, k - 1);
			flag_set_obj(inven, k, j_ptr);
		}

		set_object(compute_slot(INVEN_INVEN, j), q_ptr);

		/* Window stuff */
		flag_bool(&p_ptr->window, FLAG_PW_INVEN);
	}

	/* Message */
	if (flag) msg_print("You reorder some items in your pack.");
}

/*
 * Hack -- display an object kind in the current window
 *
 * Include list of usable spells for readible books
 */
void display_koff(s32b k_idx)
{
	s32b y;

	object_type *q_ptr;

	char o_name[80];


	/* Erase the window */
	for (y = 0; y < Term->hgt; y++)
	{
		/* Erase the line */
		Term_erase(0, y, 255);
	}

	/* No info */
	if (!k_idx) return;


	/* Get local object */
	q_ptr = new_object();

	/* Prepare the object */
	object_prep(q_ptr, k_idx);

	/* Describe */
	object_desc_store(o_name, q_ptr, FALSE, 0);
	delete_object(q_ptr);

	/* Mention the object name */
	Term_putstr(0, 0, -1, TERM_WHITE, o_name);
}


/*
 * Let the floor carry an object
 */
s16b floor_carry(s32b y, s32b x, object_type *j_ptr)
{
	j_ptr->iy         = y;
	j_ptr->ix         = x;
	j_ptr->held_m_idx = 0;

	/* Result */
	return (inven_carry_inven(&cave[y][x].inventory, j_ptr, FALSE));
}

/*
 * Notice a decaying object in the pack
 */
void pack_decay(s32b item)
{
	object_type *o_ptr;
	object_type *i_ptr;
	s32b amt;
	byte known;
	byte gone = 1;
	char desc[80];

	o_ptr = get_object(item);
	if (!o_ptr) return;

	amt = o_ptr->number;
	known = o_ptr->artifact_id;

	/* Player notices each decaying object */
	object_desc(desc, o_ptr, TRUE, 3);
	msg_format("You feel %s decompose.", desc);

	/* Get local object */
	i_ptr = new_object();

	/* Obtain local object */
	object_copy(i_ptr, o_ptr);

	/* Get rid of decayed object */
	item_increase(item, -amt);
	item_optimize(item);

	if (i_ptr->tval == TV_CORPSE)
	{
		monster_type *m_ptr;
		monster_race *r_ptr;
		s32b wt;

		if (has_flag(i_ptr, FLAG_MONSTER_OBJ))
		{
			m_ptr = flag_get_monster(&i_ptr->flags, FLAG_MONSTER_OBJ);
			r_ptr = &r_info[m_ptr->r_idx];

			/* and how much we weighed */
			wt = r_ptr->weight;

			/* Monster must have a skull for its head to become one */
			if (i_ptr->sval == SV_CORPSE_HEAD)
			{
				monster_type *m_copy = monster_type_dup(m_ptr);

				/* Replace the head with a skull */
				object_prep(i_ptr, lookup_kind(TV_CORPSE, SV_CORPSE_SKULL));
				i_ptr->weight = wt / 60 + rand_int(wt) / 600;

				flag_set_monster(&i_ptr->flags, FLAG_MONSTER_OBJ, m_copy);

				/* Stay here */
				gone = 0;
			}

			/* Monster must have a skeleton for its corpse to become one */
			if ((i_ptr->sval == SV_CORPSE_CORPSE) &&
				has_flag(r_ptr, FLAG_DROP_SKELETON))
			{
				monster_type *m_copy = monster_type_dup(m_ptr);

				/* Replace the corpse with a skeleton */
				object_prep(i_ptr, lookup_kind(TV_CORPSE, SV_CORPSE_SKELETON));
				i_ptr->weight = wt / 4 + rand_int(wt) / 40;

				flag_set_monster(&i_ptr->flags, FLAG_MONSTER_OBJ, m_copy);
				
				/* Stay here */
				gone = 0;
			}
		} /* if has_flag(o_ptr, FLAG_MONSTER_OBJ) */
		else if (wizard)
			cmsg_format(TERM_L_RED,
						"WARNING: Object %s is corpse but has no "
						"FLAG_MONSTER_OBJ defined", desc);

		/* Don't restore if the item is gone */
		if (!gone)
		{
			i_ptr->number = amt;

			/* Should become "The skull of Farmer Maggot", not "A skull" */
			if (known)
			{
				object_aware(i_ptr);

				/* Named skeletons are artifacts */
				i_ptr->artifact_id = 201;
			}
			inven_carry(i_ptr, TRUE);
		}
		else
		{
			/* Didn't used the object */
			delete_object(i_ptr);
		}
	}
}

/*
 *	Decay an object on the floor
 */
void floor_decay(object_type *o_ptr)
{
	object_type *i_ptr;
	s32b amt;
	byte known;
	byte gone = 1;

	byte x = o_ptr->ix;
	byte y = o_ptr->iy;

	/* Does the player sees it decompose? */
	bool visible = player_can_see_bold(o_ptr->iy, o_ptr->ix);
	char desc[80];

	if (visible)
	{
		/* Player notices each decaying object */
		object_desc(desc, o_ptr, TRUE, 3);
		msg_format("You see %s decompose.", desc);
	}

	amt = o_ptr->number;
	known = o_ptr->artifact_id;

	/* Get local object */
	i_ptr = new_object();

	/* Obtain local object */
	object_copy(i_ptr, o_ptr);

	if (i_ptr->tval == TV_CORPSE)
	{
		monster_type *m_ptr;
		monster_race *r_ptr;
		s32b wt;

		if (has_flag(i_ptr, FLAG_MONSTER_OBJ))
		{
			m_ptr = flag_get_monster(&i_ptr->flags, FLAG_MONSTER_OBJ);
			r_ptr = &r_info[m_ptr->r_idx];

			/* and how much we weighed */
			wt = r_ptr->weight;

			/* Monster must have a skull for its head to become one */
			if (i_ptr->sval == SV_CORPSE_HEAD)
			{
				monster_type *m_copy = monster_type_dup(m_ptr);

				/* Replace the head with a skull */
				object_prep(i_ptr, lookup_kind(TV_CORPSE, SV_CORPSE_SKULL));
				i_ptr->weight = wt / 60 + rand_int(wt) / 600;

				flag_set_monster(&i_ptr->flags, FLAG_MONSTER_OBJ, m_copy);

				/* Stay here */
				gone = 0;
			}

			/* Monster must have a skeleton for its corpse to become one */
			if ((i_ptr->sval == SV_CORPSE_CORPSE) &&
				has_flag(r_ptr, FLAG_DROP_SKELETON))
			{
				monster_type *m_copy = monster_type_dup(m_ptr);

				/* Replace the corpse with a skeleton */
				object_prep(i_ptr, lookup_kind(TV_CORPSE, SV_CORPSE_SKELETON));
				i_ptr->weight = wt / 4 + rand_int(wt) / 40;

				flag_set_monster(&i_ptr->flags, FLAG_MONSTER_OBJ, m_copy);
				
				/* Stay here */
				gone = 0;
			}
		} /* if has_flag(o_ptr, FLAG_MONSTER_OBJ) */
		else if (wizard)
			cmsg_format(TERM_L_RED,
						"WARNING: Object %s is corpse but has no "
						"FLAG_MONSTER_OBJ defined", desc);

		/* Don't restore if the item is gone */
		if (!gone)
		{
			i_ptr->number = amt;

			/* Should become "The skull of Farmer Maggot", not "A skull" */
			if (known)
			{
				object_aware(i_ptr);

				/* Named skeletons are artifacts */
				i_ptr->artifact_id = 201;
			}
			floor_carry(y, x, i_ptr);
		}
		else
		{
			/* Didn't used the object */
			delete_object(i_ptr);
		}
	}

	/* Update what the player see */
	flag_bool(&p_ptr->redraw, FLAG_PR_MAP);
}

/* Return the item be it on the floor or in inven */
object_type *get_object(s32b item)
{
	object_type *o_ptr;

	call_lua("__core_objects.get_object", "(d)", "O", item, &o_ptr);
	return o_ptr;
}

/* Sets an item in the given slot */
void set_object(s32b item, object_type *o_ptr)
{
	/* Get the item (in the pack) */
	if (item >= 0)
	{
		s32b inven = item_slot_to_inven(item);
		s32b idx = item_slot_to_item(item);
		flags_type *flags = flag_get_flags(&p_ptr->inventory, inven);
		flag_set_obj(flags, idx, o_ptr);
	}

	/* Get the item (on the floor) */
	else
	{
		cmsg_print(TERM_VIOLET, "set_object for floor unimplemented!");
	}
}
