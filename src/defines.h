/* File: defines.h */

/* Purpose: global constants and macro definitions */


/*
 * Do not edit this file unless you know *exactly* what you are doing.
 *
 * Some of the values in this file were chosen to preserve game balance,
 * while others are hard-coded based on the format of old save-files, the
 * definition of arrays in various places, mathematical properties, fast
 * computation, storage limits, or the format of external text files.
 *
 * Changing some of these values will induce crashes or memory errors or
 * savefile mis-reads.  Most of the comments in this file are meant as
 * reminders, not complete descriptions, and even a complete knowledge
 * of the source may not be sufficient to fully understand the effects
 * of changing certain definitions.
 *
 * Lastly, note that the code does not always use the symbolic constants
 * below, and sometimes uses various hard-coded values that may not even
 * be defined in this file, but which may be related to definitions here.
 * This is of course bad programming practice, but nobody is perfect...
 *
 * For example, there are MANY things that depend on the screen being
 * 80x24, with the top line used for messages, the bottom line being
 * used for status, and exactly 22 lines used to show the dungeon.
 * Just because your screen can hold 46 lines does not mean that the
 * game will work if you try to use 44 lines to show the dungeon.
 *
 * You have been warned.
 */


/*
 * Release state, CVS or not, remember to switch it when making releases
 */
#ifndef IS_CVS
/* #define IS_CVS          "" */
#define IS_CVS          "(CVS)"
#endif

/* User Agent to use */
#define HTTP_USER_AGENT		"T-Engine Micro Zsock Lib"

#define ANGBAND_2_8_1

#define SAVEFILE_VERSION 110

#define SAVEFILE_NIL            0
#define SAVEFILE_NUMBER         1
#define SAVEFILE_STRING         2
#define SAVEFILE_FLAGS          3

/* Savefile magic header */
#define SAVEFILE_MAGIC		"T-Engine Savefile"
#define SAVEFILE_MAGIC_LEN	17

/*
 * This value is not currently used
 */
#define VERSION_EXTRA   0

/*
 * Maximum amount of Angband windows.
 */
#define ANGBAND_TERM_MAX 8

/*
 * Flagy stuff
 */
#define has_flag(o, f) \
	flag_exists(&((o)->flags), f)

#define get_flag(o, f) \
	flag_get(&((o)->flags), f)

#define get_flag2(o, f) \
	flag_get2(&((o)->flags), f)

#define set_flag(o, f, v) \
	flag_set(&((o)->flags), f, v)

#define unset_flag(o, f) \
	flag_remove(&((o)->flags), f)

#define bool_flag(o, f) \
	flag_set(&((o)->flags), f, TRUE)

#define flag_bool(o, f) \
	flag_set(o, f, TRUE)

#define mod_flag(o, f, v) \
	set_flag(o, f, get_flag(o, f) + v)

#define inc_flag(o, f) \
	mod_flag(o, f, 1)

#define dec_flag(o, f) \
	mod_flag(o, f, -1)

#define FLAG_FLAG_USED          0x01            /* Node is used */
#define FLAG_FLAG_RAND          0x02            /* Node final value is a rand_range(val, val2) */
#define FLAG_FLAG_MBONUS        0x04            /* Randomization uses mbonus */
#define FLAG_FLAG_BOTH          0x08            /* Both val & val2 are used */
#define FLAG_FLAG_RAND_MBONUS	0x10            /* Randomization uses mbonus(val2) + rand(val1) */
#define FLAG_FLAG_FLAGS         0x20            /* Values are in a flagset */
#define FLAG_FLAG_PTR           0x40            /* Values are in a pointer */
#define FLAG_FLAG_KNOWN         0x80            /* Flag has been identified */

#define FLAG_TYPE_OBJ		0		/* object_type */
#define FLAG_TYPE_STRING	1		/* cptr */
#define FLAG_TYPE_MONSTER_BLOW	2		/* monster_blow */
#define FLAG_TYPE_MONSTER	3		/* monster_type */
#define FLAG_TYPE_DATA_BUFFER   4		/* buffer_type */
#define FLAG_TYPE_STORE         5		/* store_type */

#define for_flags(f_ptr) \
{ \
	{ \
		s32b __size__ = (f_ptr)->size; \
		s32b __i; \
		for (__i = 0; __i < __size__; __i++) \
		{ \
			u32b __key = (f_ptr)->node[__i].key; \
			if (!((f_ptr)->node[__i].flags & FLAG_FLAG_USED)) continue; \

#define end_for_flags() \
                } \
        } \
}

/*
 * Number of grids in each block (vertically)
 * Probably hard-coded to 11, see "generate.c"
 */
#define BLOCK_HGT	11

/*
 * Number of grids in each block (horizontally)
 * Probably hard-coded to 11, see "generate.c"
 */
#define BLOCK_WID	11

/*
 * Maximum dungeon height in grids, must be a multiple of SCREEN_HGT,
 * probably hard-coded to SCREEN_HGT * 3.
 */
#define MAX_HGT         253

/*
 * Maximum dungeon gwidth in grids, must be a multiple of SCREEN_WID,
 * probably hard-coded to SCREEN_WID * 3.
 */
#define MAX_WID         253

/*
 * Default dungeon generator rooms
 */
#define ROOM_TYPE_NORMAL	1
#define ROOM_TYPE_OVERLAPPING	2
#define ROOM_TYPE_CROSS		3
#define ROOM_TYPE_LARGE		4
#define ROOM_TYPE_NEST		5
#define ROOM_TYPE_PIT		6
#define ROOM_TYPE_LESSER_VAULT	7
#define ROOM_TYPE_GREATER_VAULT	8
#define ROOM_TYPE_CIRCULAR	9
#define ROOM_TYPE_FRACTAL	10
#define ROOM_TYPE_RANDOM_VAULT	11
#define ROOM_TYPE_CRYPT		12

/*
 * Types of places in which to find "naked" cave grids.
 */
#define ALLOC_SET_CORR  1	/* Hallway */
#define ALLOC_SET_ROOM  2	/* Room */
#define ALLOC_SET_BOTH  3	/* Anywhere */

/*
 * Default radius of detection spells
 * Its area must be at least as large as SCREEN_WID * SCREEN_HGT
 */
#define DEFAULT_RADIUS	25

/*
 * Disarm return codes.
 */
#define DISARM_SUCCESS   1
#define DISARM_FAILURE   2
#define DISARM_TRIGGERED 3

/*
 * Wall-kill return codes.
 */
#define KILLWALL_FAILURE  1 /* Tunnelling failed completely */
#define KILLWALL_WORKING  2 /* Wall isn't gone yet, but getting there */
#define KILLWALL_DONE     3 /* Wall is gone */

/*
 * Arena constants
 */
#define MAX_ARENA_MONS		29	/* -KMW- */

/* Number of Random Artifacts */
#define MAX_RANDARTS 84
#define MAX_T_ACT    51


/* Mindcraft */
#define MAX_MINDCRAFT_POWERS  12

/* Necromancy */
#define MAX_NECRO_POWERS  6

/* Mimicry */
#define MAX_MIMIC_POWERS  5

/* Symbiosis */
#define MAX_SYMBIOTIC_POWERS  9


/* A hack for cave.c */
#define BMP_FIRST_PC_CLASS 164
#define BMP_FIRST_PC_RACE 128


/*
 * Size of memory reserved for initialization of some arrays
 */
#define FAKE_NAME_SIZE  40 * 1024L
#define FAKE_TEXT_SIZE 120 * 1024L


/*
 * Maximum number of high scores in the high score file
 */
#define MAX_HISCORES    100


/*
 * Maximum dungeon level.  The player can never reach this level
 * in the dungeon, and this value is used for various calculations
 * involving object and monster creation.  It must be at least 100.
 * Setting it below 128 may prevent the creation of some objects.
 */
#define MAX_DEPTH               128
#define MAX_DEPTH_MONSTER       200


/*
 * Maximum size of the "lite" array (see "cave.c")
 * Note that the "lite radius" will NEVER exceed 5, and even if the "lite"
 * was rectangular, we would never require more than 128 entries in the array.
 */
#define LITE_MAX 1536

/*
 * Maximum size of the "view" array (see "cave.c")
 * Note that the "view radius" will NEVER exceed 20, and even if the "view"
 * was octagonal, we would never require more than 1520 entries in the array.
 */
#define VIEW_MAX 1536

/*
 * Maximum size of the "temp" array (see "cave.c")
 * We must be as large as "VIEW_MAX" and "LITE_MAX" for proper functioning
 * of "update_view()" and "update_lite()".  We must also be as large as the
 * largest illuminatable room, but no room is larger than 800 grids.  We
 * must also be large enough to allow "good enough" use as a circular queue,
 * to calculate monster flow, but note that the flow code is "paranoid".
 */
#define TEMP_MAX 16384

/*
 * Maximum number of allocation entries an item_kind object can have.
 */
#define MAX_KIND_ALLOCATIONS 4

/*
 * Maximum number of different tvals an ego can apply to.
 */
#define MAX_TVALS_PER_EGO 10

/*
 * Maximun set of flags an ego can define
 */
#define MAX_EGO_FLAG_GROUPS 10

/*
 * Maximun number of egosper objects(change = break savefiles)
 */
#define MAX_EGO_PER_OBJ 5

/*
 * Number of keymap modes
 */
#define KEYMAP_MODES	2

/*
 * Mode for original keyset commands
 */
#define KEYMAP_MODE_ORIG	0

/*
 * Mode for roguelike keyset commands
 */
#define KEYMAP_MODE_ROGUE	1


/*
 * OPTION: Maximum number of macros (see "io.c")
 * Default: assume at most 256 macros are used
 */
#define MACRO_MAX       256

/*
 * OPTION: Maximum number of "quarks" (see "io.c")
 * Default: assume at most 512 different inscriptions are used
 */
#define QUARK_MAX       768
	/* Was 512... 256 quarks added for random artifacts */

/*
 * OPTION: Maximum number of messages to remember (see "io.c")
 * Default: assume maximal memorization of 2048 total messages
 */
#define MESSAGE_MAX     2048

#define MESSAGE_NONE    0
#define MESSAGE_MSG     1
#define MESSAGE_IRC     2

/*
 * OPTION: Maximum space for the message text buffer (see "io.c")
 * Default: assume that each of the 2048 messages is repeated an
 * average of three times, and has an average length of 48
 */
#define MESSAGE_BUF     32768


/*
 * Maximum value storable in a "byte" (hard-coded)
 */
#define MAX_UCHAR       255

/*
 * Maximum value storable in a "s16b" (hard-coded)
 */
#define MAX_SHORT       32767


/*
 * Store constants
 */
#define STORE_TURNS             1000    /* Number of turns between turnovers */

/*
 * Misc constants
 */
#define BTH_PLUS_ADJ    3       /* Adjust BTH per plus-to-hit */
#define MON_MULT_ADJ    10              /* High value slows multiplication */
#define MON_SUMMON_ADJ  2               /* Adjust level of summoned creatures */
#define MON_DRAIN_LIFE  2               /* Percent of player exp drained per hit */
#define USE_DEVICE      3               /* x> Harder devices x< Easier devices     */

/*
 * Location of objects when they were found
 */
#define OBJ_FOUND_MONSTER       1
#define OBJ_FOUND_FLOOR         2
#define OBJ_FOUND_VAULT         3
#define OBJ_FOUND_SPECIAL       4
#define OBJ_FOUND_RUBBLE        5
#define OBJ_FOUND_REWARD        6
#define OBJ_FOUND_STORE         7
#define OBJ_FOUND_STOLEN        8
#define OBJ_FOUND_SELFMADE      9
#define OBJ_FOUND_WISH         10
#define OBJ_FOUND_DEBUG        11
#define OBJ_FOUND_START        12

/*
 * There is a 1/20 (5%) chance of inflating the requested object_level
 * during the creation of an object.
 * Previously used for all item creation, now only used for treasure.
 * (see "make_gold()" in object2.c)
 * Lower values yield better objects more often.
 */
#define GREAT_OBJ       20

#define GREAT_EGO       20

/*
 * There is a 1/50 (2%) chance of inflating the requested monster_level
 * during the creation of a monsters (see "get_mon_num()" in "monster.c").
 * Lower values yield harder monsters more often.
 */
#define NASTY_MON       50              /* 1/chance of inflated monster level */



/*
 * Refueling constants
 */
#define FUEL_TORCH      5000    /* Maximum amount of fuel in a torch */
#define FUEL_LAMP       15000   /* Maximum amount of fuel in a lantern */


/*
 * More maximum values
 */
#define MAX_SIGHT       20      /* Maximum view distance */
#define MAX_RANGE       18      /* Maximum range (spells, etc) */



/*
 * The town starts out with 4 residents during the day
 */
#define MIN_M_ALLOC_TD          4

/*
 * The town starts out with 8 residents during the night
 */
#define MIN_M_ALLOC_TN          8


/*
 * A monster can only "multiply" (reproduce) if there are fewer than 100
 * monsters on the level capable of such spontaneous reproduction.  This
 * is a hack which prevents the "m_list[]" array from exploding due to
 * reproducing monsters.  Messy, but necessary.
 */
#define MAX_REPRO       100


/*
 * Player constants
 */
#define SUBRACE_PLACE_AFTER	0
#define SUBRACE_PLACE_BEFORE	1
#define SUBRACE_PLACE_REPLACE	2
#define SUBRACE_SAVE    1               /* Ugly hack, should be in foo-info, the subrace saved to the savefile */

/* Energy constants */
#define TURN_ENERGY 	1000 /* Energy used in one player turn. */
#define TICK_ENERGY 	100  /* Energy given in one game turn. */
#define MAX_SPEED       100   /* Maximun speed reachable */
#define MIN_SPEED      -100   /* Minimun speed reachable */

/*
 * Indexes used for various "equipment" slots (hard-coded by savefiles, etc).
 */
#define INVEN_INVEN     0

#define INVEN_MAX_SIZE  100

#define INVEN_LIMIT_KEY 0

/*
 * A "stack" of items is limited to less than 100 items (hard-coded).
 */
#define MAX_STACK_SIZE                  100

/* Various inventory "function" */
#define for_inventory_copy(src, o_ptr, start, end) \
{ \
	s32b inven_nb; \
	for (inven_nb = (start); inven_nb < (end); inven_nb++) \
	{ \
		flags_type *__flags__ = flag_shallow_dup(flag_get_flags(&(src)->inventory, inven_nb));\
		s32b __size__ = flag_max_key(__flags__); \
		s32b item_nb; \
		for (item_nb = 1; item_nb <= __size__; item_nb++) \
		{ \
			object_type *o_ptr = flag_get_obj(__flags__, item_nb); \
			s32b item_slot = compute_slot(inven_nb, item_nb); \
			item_slot = item_slot; \
			if (o_ptr == NULL) continue;

#define end_inventory_copy() \
		} \
		flag_shallow_free(__flags__, TRUE);\
	} \
}


/* readonly version is (perhaps very slightly) faster */
#define for_inventory_ro(src, o_ptr, start, end) \
{ \
	s32b inven_nb; \
	for (inven_nb = (start); inven_nb < (end); inven_nb++) \
	{ \
		flags_type *__flags__ = flag_get_flags(&(src)->inventory, inven_nb); \
		s32b __size__; \
		s32b item_nb; \
		if (!__flags__) continue; \
		__size__ = flag_max_key(__flags__); \
		for (item_nb = 1; item_nb <= __size__; item_nb++) \
		{ \
			object_type *o_ptr = flag_get_obj(__flags__, item_nb); \
			s32b item_slot = compute_slot(inven_nb, item_nb); \
			item_slot = item_slot; \
			if (o_ptr == NULL) continue;

#define end_inventory() \
		} \
	} \
}

#define for_inventory(src, o_ptr, start, end) for_inventory_ro(src,o_ptr,start,end)

#define for_inventory_slot(inven, o_ptr) \
{ \
	{ \
		s32b __size__ = flag_max_key(inven); \
		flags_type *__inven_copy = flag_shallow_dup(inven); \
		s32b item_nb; \
		for (item_nb = 1; item_nb <= __size__; item_nb++) \
		{ \
			object_type *o_ptr = flag_get_obj(__inven_copy, item_nb); \
			if (o_ptr == NULL) continue;

#define end_inventory_slot() \
                } \
                flag_shallow_free(__inven_copy, TRUE);\
        } \
}

/* _ro version slightly faster doesn't copy */

#define for_inventory_slot_ro(inven, o_ptr) \
{ \
	{ \
		s32b __size__ = flag_max_key(inven); \
		s32b item_nb; \
		for (item_nb = 1; item_nb <= __size__; item_nb++) \
		{ \
			object_type *o_ptr = flag_get_obj(inven, item_nb); \
			if (o_ptr == NULL) continue;


#define compute_slot(inven, item) ((inven * INVEN_MAX_SIZE) + item)

#define get_object_split(inven, item) get_object(compute_slot(inven, item))

#define item_slot_to_inven(slot) (slot / INVEN_MAX_SIZE)
#define item_slot_to_item(slot) (slot % INVEN_MAX_SIZE)

#define inventory_limit(slot) (flag_get(get_inven(p_ptr, slot), INVEN_LIMIT_KEY))
#define inventory_limit_inven(inven) (flag_get(inven, INVEN_LIMIT_KEY))

#define get_inven(src, inven) (flag_get_flags(&src->inventory, inven))

#define inventory_delete(item) (flag_remove(get_inven(p_ptr, item_slot_to_inven(item)), item_slot_to_item(item)))

/* 1 and not 0 because of INVEN_LIMIT_KEY used to store the inventory size */
#define is_inven_empty(inven) (flag_used(inven) == 1)


/*
 * Player sex constants (hard-coded by save-files, arrays, etc)
 */
#define SEX_FEMALE              0
#define SEX_MALE                1
#define SEX_NEUTER              2

/* XXX */
#define MKEY_MINDCRAFT          2
#define MKEY_ANTIMAGIC          3
#define MKEY_BLADE              4
#define MKEY_ALCHEMY            5
#define MKEY_MIMIC              6
#define MKEY_NECRO              7
#define MKEY_POWER_MAGE         8
#define MKEY_RUNE               9
#define MKEY_FORGING            10
#define MKEY_INCARNATION        11
/* XXX */
#define MKEY_SUMMON             13
#define MKEY_TRAP               14
#define MKEY_STEAL              15
#define MKEY_DODGE              16
#define MKEY_SCHOOL             17
#define MKEY_LEARN              18
#define MKEY_COPY               19
#define MKEY_SYMBIOTIC          20
#define MKEY_BOULDER            21
#define MKEY_COMPANION          22
#define MKEY_PIERCING           23


#define MAX_BETWEEN_EXITS       2

/*
 * Number of effects
 */
#define MAX_EFFECTS             128
#define EFF_WAVE                0x00000001      /* A circle whose radius increase */
#define EFF_LAST                0x00000002      /* The wave lasts */
#define EFF_STORM               0x00000004      /* The area follows the player */
#define EFF_DIR1                0x00000008      /* Directed effect */
#define EFF_DIR2                0x00000010      /* Directed effect */
#define EFF_DIR3                0x00000020      /* Directed effect */
#define EFF_DIR4                0x00000040      /* Directed effect */
#define EFF_DIR6                0x00000080      /* Directed effect */
#define EFF_DIR7                0x00000100      /* Directed effect */
#define EFF_DIR8                0x00000200      /* Directed effect */
#define EFF_DIR9                0x00000400      /* Directed effect */

/*
 * Wilderness terrains
 */
#define TERRAIN_EDGE             0 /* Edge of the World */
#define TERRAIN_TOWN             1 /* Town */
#define TERRAIN_DEEP_WATER       2 /* Deep water */
#define TERRAIN_SHALLOW_WATER    3 /* Shallow water */
#define TERRAIN_SWAMP            4 /* Swamp */
#define TERRAIN_DIRT             5 /* Dirt */
#define TERRAIN_GRASS            6 /* Grass */
#define TERRAIN_TREES            7 /* Trees */
#define TERRAIN_DESERT           8 /* Desert */
#define TERRAIN_SHALLOW_LAVA     9 /* Shallow lava */
#define TERRAIN_DEEP_LAVA       10 /* Deep lava */
#define TERRAIN_MOUNTAIN        11 /* Mountain */

#define MAX_WILD_TERRAIN        18

/* Activation effects for random artifacts */
#define ACT_SUNLIGHT            1
#define ACT_BO_MISS_1           2
#define ACT_BA_POIS_1           3
#define ACT_BO_ELEC_1           4
#define ACT_BO_ACID_1           5
#define ACT_BO_COLD_1           6
#define ACT_BO_FIRE_1           7
#define ACT_BA_COLD_1           8
#define ACT_BA_FIRE_1           9
#define ACT_DRAIN_1             10
#define ACT_BA_COLD_2           11
#define ACT_BA_ELEC_2           12
#define ACT_DRAIN_2             13
#define ACT_VAMPIRE_1           14
#define ACT_BO_MISS_2           15
#define ACT_BA_FIRE_2           16
#define ACT_BA_COLD_3           17
#define ACT_BA_ELEC_3           18
#define ACT_WHIRLWIND           19
#define ACT_VAMPIRE_2           20
#define ACT_CALL_CHAOS          21
#define ACT_ROCKET              22
#define ACT_DISP_EVIL           23
#define ACT_BA_MISS_3           24
#define ACT_DISP_GOOD           25
#define ACT_GILGALAD            26
#define ACT_CELEBRIMBOR         27
#define ACT_SKULLCLEAVER        28
#define ACT_HARADRIM            29
#define ACT_FUNDIN              30
#define ACT_EOL                 31
#define ACT_UMBAR               32
#define ACT_NUMENOR             33
#define ACT_KNOWLEDGE           34
#define ACT_UNDEATH             35
#define ACT_THRAIN              36
#define ACT_BARAHIR             37
#define ACT_TULKAS              38
#define ACT_NARYA               39
#define ACT_NENYA               40
#define ACT_VILYA               41
#define ACT_POWER               42
#define ACT_STONE_LORE          43
#define ACT_RAZORBACK           44
#define ACT_BLADETURNER         45
#define ACT_MEDIATOR            46
#define ACT_BELEGENNON          47
#define ACT_GORLIM              48
#define ACT_COLLUIN             49
#define ACT_BELANGIL            50
#define ACT_CONFUSE             51
#define ACT_SLEEP               52
#define ACT_QUAKE               53
#define ACT_TERROR              54
#define ACT_TELE_AWAY           55
#define ACT_BANISH_EVIL         56
#define ACT_GENOCIDE            57
#define ACT_MASS_GENO           58
#define ACT_ANGUIREL            59
#define ACT_ERU                 60
#define ACT_DAWN                61
#define ACT_FIRESTAR            62
#define ACT_TURMIL              63
#define ACT_CUBRAGOL            64
#define ACT_CHARM_ANIMAL        65
#define ACT_CHARM_UNDEAD        66
#define ACT_CHARM_OTHER         67
#define ACT_CHARM_ANIMALS       68
#define ACT_CHARM_OTHERS        69
#define ACT_SUMMON_ANIMAL       70
#define ACT_SUMMON_PHANTOM      71
#define ACT_SUMMON_ELEMENTAL    72
#define ACT_SUMMON_DEMON        73
#define ACT_SUMMON_UNDEAD       74
#define ACT_ELESSAR             75
#define ACT_GANDALF             76
#define ACT_MARDA               77
#define ACT_PALANTIR            78
/*
                                79
                                80
*/
#define ACT_CURE_LW             81
#define ACT_CURE_MW             82
#define ACT_CURE_POISON         83
#define ACT_REST_LIFE           84
#define ACT_REST_ALL            85
#define ACT_CURE_700            86
#define ACT_CURE_1000           87
/*
                                88
*/
#define ACT_EREBOR              89
#define ACT_DRUEDAIN            90
#define ACT_ESP                 91
#define ACT_BERSERK             92
#define ACT_PROT_EVIL           93
#define ACT_RESIST_ALL          94
#define ACT_SPEED               95
#define ACT_XTRA_SPEED          96
#define ACT_WRAITH              97
#define ACT_INVULN              98
#define ACT_ROHAN               99
#define ACT_HELM                100
#define ACT_BOROMIR             101
#define ACT_HURIN               102
#define ACT_AXE_GOTHMOG         103
#define ACT_MELKOR              104
#define ACT_GROND               105
#define ACT_NATUREBANE          106
#define ACT_NIGHT               107
#define ACT_ORCHAST             108
#define ACT_LIGHT               111
#define ACT_MAP_LIGHT           112
#define ACT_DETECT_ALL          113
#define ACT_DETECT_XTRA         114
#define ACT_ID_FULL             115
#define ACT_ID_PLAIN            116
#define ACT_RUNE_EXPLO          117
#define ACT_RUNE_PROT           118
#define ACT_SATIATE             119
#define ACT_DEST_DOOR          120
#define ACT_STONE_MUD           121
#define ACT_RECHARGE            122
#define ACT_ALCHEMY             123
#define ACT_DIM_DOOR            124
#define ACT_TELEPORT            125
#define ACT_RECALL              126

#define ACT_DEATH               127
#define ACT_RUINATION           128
#define ACT_DESTRUC             129
#define ACT_UNINT               130
#define ACT_UNSTR               131
#define ACT_UNCON               132
#define ACT_UNCHR               133
#define ACT_UNDEX               134
#define ACT_UNWIS               135
#define ACT_STATLOSS            136
#define ACT_HISTATLOSS          137
#define ACT_EXPLOSS             138
#define ACT_HIEXPLOSS           139
#define ACT_SUMMON_MONST        140
#define ACT_PARALYZE            141
#define ACT_HALLU               142
#define ACT_POISON              143
#define ACT_HUNGER              144
#define ACT_STUN                145
#define ACT_CUTS                146
#define ACT_PARANO              147
#define ACT_CONFUSION           148
#define ACT_BLIND               149
#define ACT_PET_SUMMON          150
#define ACT_CURE_PARA           151
#define ACT_CURE_HALLU          152
#define ACT_CURE_POIS           153
#define ACT_CURE_HUNGER         154
#define ACT_CURE_STUN           155
#define ACT_CURE_CUTS           156
#define ACT_CURE_FEAR           157
#define ACT_CURE_CONF           158
#define ACT_CURE_BLIND          159
#define ACT_CURING              160
#define ACT_DARKNESS            161
#define ACT_LEV_TELE            162
#define ACT_ACQUIREMENT         163
#define ACT_WEIRD               164
#define ACT_AGGRAVATE           165
#define ACT_MUT                 166
#define ACT_CURE_INSANITY       167
#define ACT_CURE_MUT            168
#define ACT_LIGHT_ABSORBTION    169
/* of dragonkind?*/
#define ACT_BA_FIRE_H           170
#define ACT_BA_COLD_H           171
#define ACT_BA_ELEC_H           172
#define ACT_BA_ACID_H           173
#define ACT_SPIN                174
#define ACT_NOLDOR              175
#define ACT_SPECTRAL            176
#define ACT_JUMP                177
#define ACT_DEST_TELE           178
/*amulet of serpents dam 100, rad 2 timout 40+d60 */
#define ACT_BA_POIS_4           179
/*rings of X 50,50+d50 dur 20+d20 */
#define ACT_BA_COLD_4           180
#define ACT_BA_FIRE_4           181
#define ACT_BA_ACID_4           182
#define ACT_BA_ELEC_4           183
#define ACT_BR_ELEC             184
#define ACT_BR_COLD             185
#define ACT_BR_FIRE             186
#define ACT_BR_ACID             187
#define ACT_BR_POIS             188
#define ACT_BR_MANY             189
#define ACT_BR_CONF             190
#define ACT_BR_SOUND            191
#define ACT_BR_CHAOS            192
#define ACT_BR_SHARD            193
#define ACT_BR_BALANCE          194
#define ACT_BR_LIGHT            195
#define ACT_BR_POWER            196
#define ACT_GROW_MOLD			197
#define ACT_MUSIC				200
/* 170 -> unused */

/*** Object "tval" and "sval" codes ***/


/*
 * The values for the "tval" field of various objects.
 *
 * This value is the primary means by which items are sorted in the
 * player inventory, followed by "sval" and "cost".
 *
 * Note that a "BOW" with tval = 19 and sval S = 10*N+P takes a missile
 * weapon with tval = 16+N, and does (xP) damage when so combined.  This
 * fact is not actually used in the source, but it kind of interesting.
 *
 * Note that as of 2.7.8, the "item flags" apply to all items, though
 * only armor and weapons and a few other items use any of these flags.
 */

#define TV_CORPSE        1      /* Monster corpses */

/* The "sval" codes for TV_CORPSE */
#define SV_CORPSE_CORPSE     1
#define SV_CORPSE_SKELETON   2
#define SV_CORPSE_HEAD       3
#define SV_CORPSE_SKULL      4
#define SV_CORPSE_MEAT       5

/*** General flag values ***/


/*
 * Special cave grid flags
 */
#define CAVE_MARK       0x0001    /* memorized feature */
#define CAVE_GLOW       0x0002    /* self-illuminating */
#define CAVE_ICKY       0x0004    /* part of a vault */
#define CAVE_ROOM       0x0008    /* part of a room */
#define CAVE_SEEN       0x0010    /* seen flag  */
#define CAVE_VIEW       0x0020    /* view flag */
#define CAVE_TEMP       0x0040    /* temp flag */
#define CAVE_WALL       0x0080    /* wall flag */
#define CAVE_TRDT       0x0100    /* trap detected */
#define CAVE_IDNT       0x0200    /* grid identified (fountains) */
#define CAVE_SPEC       0x0400    /* special mark(quests) */
#define CAVE_FREE       0x0800    /* no random generation on it */
#define CAVE_DETECT     0x1000    /* Traps detected here */
#define CAVE_PLIT       0x2000    /* Player lit grid */
#define CAVE_MLIT       0x4000    /* Monster lit grid */

/*
 * Bit flags for the "project()" function
 *
 *   JUMP: Jump directly to the target location (this is a hack)
 *   BEAM: Work as a beam weapon (affect every grid passed through)
 *   THRU: Continue "through" the target (used for "bolts"/"beams")
 *   WALL: Continue "through" the walls
 *   STOP: Stop as soon as we hit a monster (used for "bolts")
 *   GRID: Affect each grid in the "blast area" in some way
 *   ITEM: Affect each object in the "blast area" in some way
 *   KILL: Affect each monster in the "blast area" in some way
 *   HIDE: Hack -- disable "visual" feedback from projection
 */
#define PROJECT_JUMP       	0x00000001
#define PROJECT_BEAM       	0x00000002
#define PROJECT_THRU       	0x00000004
#define PROJECT_STOP       	0x00000008
#define PROJECT_GRID       	0x00000010
#define PROJECT_ITEM       	0x00000020
#define PROJECT_KILL       	0x00000040
#define PROJECT_HIDE       	0x00000080
#define PROJECT_VIEWABLE   	0x00000100   /* Affect monsters in LOS */
#define PROJECT_METEOR_SHOWER 	0x00000200        /* Affect random grids */
#define PROJECT_BLAST      	0x00000400   /* Like Mega_blast, but will only affect viewable grids */
#define PROJECT_PANEL      	0x00000800   /* Affect everything in the panel. */
#define PROJECT_ALL        	0x00001000   /* Affect every single grid. */
#define PROJECT_WALL       	0x00002000
#define PROJECT_MANA_PATH  	0x00004000   /* Follow a mana path. */
#define PROJECT_ABSORB_MANA 	0x00008000   /* The spell increase in power as it absord grid's mana. */
#define PROJECT_STAY       	0x00010000
#define PROJECT_CASTER     	0x00020000   /* Caster can be affected by his/her own spells */
#define PROJECT_CONE       	0x00040000   /* Takes the form of a cone instead of a ball */
#define PROJECT_HIDE_BLAST 	0x00080000   /* Hide the blast area */
#define PROJECT_NO_REFLECT 	0x00100000   /* Not affected by reflection */
#define PROJECT_SILENT     	0x00200000   /* Monsters wont scream */
#define PROJECT_NO_RADIUS_DAM   0x00400000   /* Do not reduce power with radius */

/*
 * Bit flags for the "target_set" function XXX XXX XXX
 *
 *      KILL: Target monsters
 *      LOOK: Describe grid fully
 *      XTRA: Currently unused flag
 *      GRID: Select from all grids
 */
#define TARGET_KILL             0x01
#define TARGET_LOOK             0x02
#define TARGET_XTRA             0x04
#define TARGET_GRID             0x08


/*
 * Some bit-flags for the "smart" field
 */
#define SM_RES_ACID             0x00000001
#define SM_RES_ELEC             0x00000002
#define SM_RES_FIRE             0x00000004
#define SM_RES_COLD             0x00000008
#define SM_RES_POIS             0x00000010
#define SM_RES_NETH             0x00000020
#define SM_RES_LITE             0x00000040
#define SM_RES_DARK             0x00000080
#define SM_RES_FEAR             0x00000100
#define SM_RES_CONF             0x00000200
#define SM_RES_CHAOS            0x00000400
#define SM_RES_DISEN            0x00000800
#define SM_RES_BLIND            0x00001000
#define SM_RES_NEXUS            0x00002000
#define SM_RES_SOUND            0x00004000
#define SM_RES_SHARD            0x00008000
#define SM_OPP_ACID             0x00010000
#define SM_OPP_ELEC             0x00020000
#define SM_OPP_FIRE             0x00040000
#define SM_OPP_COLD             0x00080000
#define SM_OPP_POIS             0x00100000
#define SM_OPP_XXX1             0x00200000
#define SM_CLONED               0x00400000
#define SM_NOTE_TRAP            0x00800000
#define SM_IMM_ACID             0x01000000
#define SM_IMM_ELEC             0x02000000
#define SM_IMM_FIRE             0x04000000
#define SM_IMM_COLD             0x08000000
#define SM_IMM_XXX5             0x10000000
#define SM_IMM_REFLECT          0x20000000
#define SM_IMM_FREE             0x40000000
#define SM_IMM_MANA             0x80000000

/*
 * Monster factions, indexes factions hashtable
 */
#define FACTION_PLAYER          0
#define FACTION_TOWN            1
#define FACTION_DUNGEON         2

/*
 * Bit flags for the "get_item" function
 */
#define USE_EQUIP    0x01	/* Allow equip items */
#define USE_INVEN    0x02	/* Allow inven items */
#define USE_FLOOR    0x04	/* Allow floor items */
#define USE_EXTRA    0x08	/* Allow extra items */
#define USE_AUTO     0x10	/* Allow creation of automatizer rule */
#define USE_DISPLAY  0x20	/* Displays the list automatically */
#define USE_SHOW_NO_ITEM 0x40	/* Shows a "list" even if empty */

/*
 * Bit flags for the "p_ptr->notice" variable
 */
#define PN_COMBINE      0x00000001L     /* Combine the pack */
#define PN_REORDER      0x00000002L     /* Reorder the pack */
/* xxx (many) */


/*
 * Bit flags for the "p_ptr->update" variable
 */
#define PU_BONUS        0x00000001L     /* Calculate bonuses */
#define PU_TORCH        0x00000002L     /* Calculate torch radius */
#define PU_BODY         0x00000004L     /* Calculate body parts */
#define PU_SANITY       0x00000008L     /* Calculate csan and msan */
#define PU_HP           0x00000010L     /* Calculate chp and mhp */
#define PU_MANA         0x00000020L     /* Calculate csp and msp */
#define PU_SPELLS       0x00000040L     /* Calculate spells */
#define PU_POWERS       0x00000080L     /* Calculate powers */
/* xxx (many) */
#define PU_UN_VIEW      0x00010000L     /* Forget view */
/* xxx (many) */
#define PU_VIEW         0x00100000L     /* Update view */
#define PU_MON_LITE     0x00200000L     /* Update monster light */
/* xxx */
#define PU_MONSTERS     0x01000000L     /* Update monsters */
#define PU_DISTANCE     0x02000000L     /* Update distances */
/* xxx */
#define PU_FLOW         0x10000000L     /* Update flow */
/* xxx (many) */

/* jk */
#define STAT_DEC_TEMPORARY 1
#define STAT_DEC_NORMAL 2
#define STAT_DEC_PERMANENT 3

/*** General index values ***/


/*
 * Spell types used by project(), and related functions.
 */
#define WHO_PLAYER      0
#define WHO_TRAP	-2
#define WHO_DUNGEON     -100
#define WHO_FLOOR       -101


/*
 * Some things which induce learning
 */
#define DRS_ACID         1
#define DRS_ELEC         2
#define DRS_FIRE         3
#define DRS_COLD         4
#define DRS_POIS         5
#define DRS_NETH         6
#define DRS_LITE         7
#define DRS_DARK         8
#define DRS_FEAR         9
#define DRS_CONF        10
#define DRS_CHAOS       11
#define DRS_DISEN       12
#define DRS_BLIND       13
#define DRS_NEXUS       14
#define DRS_SOUND       15
#define DRS_SHARD       16
#define DRS_FREE        30
#define DRS_MANA        31
#define DRS_REFLECT     32

/*
 * Hack -- first "normal" artifact in the artifact list.  All of
 * the artifacts with indexes from 1 to 15 are "special" (lights,
 * rings, amulets), and the ones from 16 to 127 are "normal".
 */
#define ART_MIN_NORMAL          16
#define ART_MIN_SPECIAL         200


/*** Object flag values ***/


/*
 * Special Object Flags
 */
#define IDENT_SENSE             0x01    /* Item has been "sensed" */
#define IDENT_FIXED             0x02    /* Item has been "haggled" */
#define IDENT_EMPTY             0x04    /* Item charges are known */
#define IDENT_KNOWN             0x08    /* Item abilities are known */
#define IDENT_STOREB            0x10    /* Item is storebought !!!! */
#define IDENT_MENTAL            0x20    /* Item information is known */
#define IDENT_CURSED            0x40    /* Item is temporarily cursed */



/*
 * Special Monster Flags
 */
#define MFLAG_VIEW      0x00000001    /* Monster is in line of sight */
#define MFLAG_QUEST     0x00000002    /* Monster is subject to a quest */
#define MFLAG_PARTIAL   0x00000004    /* Monster is a partial summon */
#define MFLAG_CONTROL   0x00000008    /* Monster is controlled */
#define MFLAG_BORN      0x00000010    /* Monster is still being born */
#define MFLAG_NICE      0x00000020    /* Monster is still being nice */
#define MFLAG_SHOW      0x00000040    /* Monster is recently memorized */
#define MFLAG_MARK      0x00000080    /* Monster is currently memorized */
#define MFLAG_NO_DROP   0x00000100    /* Monster wont drop obj/corpse */
#define MFLAG_QUEST2    0x00000200    /* Monster is subject to a quest */
#define PERM_MFLAG_MASK ( \
        MFLAG_QUEST | MFLAG_QUEST2 | \
        MFLAG_PARTIAL | MFLAG_CONTROL | MFLAG_NO_DROP \
        )

/* Number of group of flags to choose from */
#define MAX_FLAG_GROUP          12
#define NEW_GROUP_CHANCE        40      /* Chance to get a new group */

/*** Town flags ***/
#define TOWN_REAL	0x01	/* Town is really present */
#define TOWN_KNOWN	0x02	/* Town is found by the player */



/*** Monster blow constants ***/

#define MODIFY_AUX(o, n) ((o) = modify_aux((o), (n) >> 2, (n) & 3))
#define MODIFY(o, n, min) MODIFY_AUX(o, n); (o) = ((o) < (min))?(min):(o)

/*
 * New monster blow methods
 */
#define RBM_ANY          0
#define RBM_HIT          1
#define RBM_TOUCH        2
#define RBM_PUNCH        3
#define RBM_KICK         4
#define RBM_CLAW         5
#define RBM_BITE         6
#define RBM_STING        7
#define RBM_XXX1         8
#define RBM_BUTT         9
#define RBM_CRUSH       10
#define RBM_ENGULF      11
#define RBM_CHARGE      12
#define RBM_CRAWL       13
#define RBM_DROOL       14
#define RBM_SPIT        15
#define RBM_EXPLODE     16
#define RBM_GAZE        17
#define RBM_WAIL        18
#define RBM_SPORE       19
#define RBM_XXX4        20
#define RBM_BEG         21
#define RBM_INSULT      22
#define RBM_MOAN        23
#define RBM_SHOW        24


/*
 * New monster blow effects
 */
#define RBE_ANY          0
#define RBE_HURT         1
#define RBE_POISON       2
#define RBE_UN_BONUS     3
#define RBE_UN_POWER     4
#define RBE_EAT_GOLD     5
#define RBE_EAT_ITEM     6
#define RBE_EAT_FOOD     7
#define RBE_EAT_LITE     8
#define RBE_ACID         9
#define RBE_ELEC        10
#define RBE_FIRE        11
#define RBE_COLD        12
#define RBE_BLIND       13
#define RBE_CONFUSE     14
#define RBE_TERRIFY     15
#define RBE_PARALYZE    16
#define RBE_LOSE_STR    17
#define RBE_LOSE_INT    18
#define RBE_LOSE_WIS    19
#define RBE_LOSE_DEX    20
#define RBE_LOSE_CON    21
#define RBE_LOSE_CHR    22
#define RBE_LOSE_ALL    23
#define RBE_SHATTER     24
#define RBE_EXP_10      25
#define RBE_EXP_20      26
#define RBE_EXP_40      27
#define RBE_EXP_80      28
#define RBE_DISEASE     29
#define RBE_TIME        30
#define RBE_SANITY      31
#define RBE_HALLU       32
#define RBE_PARASITE    33
#define RBE_ABOMINATION 34


/*** Monster flag values (hard-coded) ***/

#define MONSTER_LEVEL_MAX       150
#define MONSTER_EXP(level)      ((((level) > MONSTER_LEVEL_MAX)?MONSTER_LEVEL_MAX:(level)) * (((level) > MONSTER_LEVEL_MAX)?MONSTER_LEVEL_MAX:(level)) * (((level) > MONSTER_LEVEL_MAX)?MONSTER_LEVEL_MAX:(level)) * 6)

/*** Macro Definitions ***/


/*
 * Hack -- The main "screen"
 */
#define term_screen     (angband_term[0])


/*
 * Determine if a given inventory item is "known"
 * Test One -- Check for special "known" tag
 * Test Two -- Check for "Easy Know" + "Aware"
 */
#define object_known_p(T) \
    (((T)->ident & (IDENT_KNOWN)) || \
     (k_info[(T)->k_idx].easy_know && object_aware_p(T) && \
      !artifact_p(T)))


/*
 * Return the "attr" for a given item.
 * Use "flavor" if available.
 * Default to user definitions.
 */
#define object_attr(T) \
	((T)->x_attr)

#define object_attr_default(T) \
	((T)->d_attr)

/*
 * Return the "char" for a given item.
 * Use "flavor" if available.
 * Default to user definitions.
 */
#define object_char(T) \
        (k_info[(T)->k_idx].x_char)

#define object_char_default(T) \
	(k_info[(T)->k_idx].d_char)



/*
 * Artifacts use the "artifact_id" field
 */
#define artifact_p(T) \
	(                                                               \
	((T)->artifact_id ? TRUE : FALSE) ||                                  \
	((T)->art_name ? TRUE : FALSE) ||                               \
	flag_exists(&((T)->flags), FLAG_NORM_ART)                       \
	)

/*
 * Ego-Items use the "ego_id" field
 */
#define ego_item_p(T) \
	((T)->ego_id[0] ? TRUE : FALSE)

/*
 * Ego-Items use the "ego_id" field
 */
#define is_ego_p(T, e) \
	((T)->ego_id[0] == (e))



/*
 * Cursed items.
 */
#define cursed_p(T) \
	((T)->ident & (IDENT_CURSED))


/*
 * Convert an "attr"/"char" pair into a "pict" (P)
 */
#define PICT(A,C) \
	((((u16b)(A)) << 8) | ((byte)(C)))

/*
 * Convert a "pict" (P) into an "attr" (A)
 */
#define PICT_A(P) \
	((byte)((P) >> 8))

/*
 * Convert a "pict" (P) into an "char" (C)
 */
#define PICT_C(P) \
	((char)((byte)(P)))


/*
 * Convert a "location" (Y,X) into a "grid" (G)
 */
#define GRID(Y,X) \
	(256 * (Y) + (X))

/*
 * Convert a "grid" (G) into a "location" (Y)
 */
#define GRID_Y(G) \
	((s32b)((G) / 256U))

/*
 * Convert a "grid" (G) into a "location" (X)
 */
#define GRID_X(G) \
	((s32b)((G) % 256U))


/*
 * Determines if a map location is fully inside the outer walls
 */
#define in_bounds(Y,X) \
   (((Y) > 0) && ((X) > 0) && ((Y) < cur_hgt-1) && ((X) < cur_wid-1))

/*
 * Determines if a map location is on or inside the outer walls
 */
#define in_bounds2(Y,X) \
   (((Y) >= 0) && ((X) >= 0) && ((Y) < cur_hgt) && ((X) < cur_wid))


/*
 * Determines if a map location is currently "on screen" -RAK-
 * Note that "panel_contains(Y,X)" always implies "in_bounds2(Y,X)".
 */
#define panel_contains(Y,X) \
  (((Y) >= panel_row_min) && ((Y) <= panel_row_max) && \
   ((X) >= panel_col_min) && ((X) <= panel_col_max))



/*
 * Determine if a "legal" grid is a "floor" grid
 *
 * Line 1 -- forbid doors, rubble, seams, walls
 *
 * Note that the terrain features are split by a one bit test
 * into those features which block line of sight and those that
 * do not, allowing an extremely fast single bit check below.
 *
 * Add in the fact that some new terrain (water & lava) do NOT block sight
 * -KMW-
 */
#define cave_floor_bold(Y,X) \
	(has_flag(&f_info[cave[Y][X].feat], FLAG_FLOOR))

/*
 * Determine if a "legal" grid is a "wall" grid
 */
#define cave_wall_bold(Y,X) \
	(has_flag(&f_info[cave[Y][X].feat], FLAG_WALL))

/*
 * Determine if a "legal" grid has CAN_PASS
 */
#define cave_pass_bold(Y,X) \
	(has_flag(&f_info[cave[Y][X].feat], FLAG_CAN_PASS))


/*
 * Determine if a "legal" grid is floor without the REMEMBER flag set
 * Sometimes called "boring" grid
 */
#define cave_plain_floor_bold(Y,X) \
	(has_flag(&f_info[cave[Y][X].feat], FLAG_FLOOR) && \
	 !has_flag(&f_info[cave[Y][X].feat], FLAG_REMEMBER))

#define c_ptr_mimic_or_feat(C_PTR) \
	((C_PTR)->mimic != 0 ? (C_PTR)->mimic : (C_PTR)->feat)

#define cave_mimic_or_feat(Y, X) c_ptr_mimic_or_feat(&cave(y, x).c_ptr)

/*
 * Determine if a "legal" grid isn't a "blocking line of sight" grid
 *
 * Line 1 -- forbid doors, rubble, seams, walls
 *
 * Note that the terrain features are split by a one bit test
 * into those features which block line of sight and those that
 * do not, allowing an extremely fast single bit check below.
 *
 * Add in the fact that some new terrain (water & lava) do NOT block sight
 * -KMW-
 */
#define cave_sight_grid(C) \
	(!has_flag(&f_info[(C)->mimic == 0 ? (C)->feat : (C)->mimic], \
     FLAG_NO_VISION))
#define cave_sight_bold(Y,X) cave_sight_grid(&cave[Y][X])

/*
 * Determine if a "legal" grid is a "clean" floor grid
 *
 * Line 1 -- forbid non-floors
 * Line 2 -- forbid deep water -KMW-
 * Line 3 -- forbid deep lava -KMW-
 * Line 4 -- forbid normal objects
 */
#define cave_clean_bold(Y,X) \
	((has_flag(&f_info[cave[Y][X].feat], FLAG_FLOOR)) && \
	 is_inven_empty(&cave[Y][X].inventory) && \
	 !has_flag(&f_info[cave[Y][X].feat], FLAG_PERMANENT))


/*
 * Determine if a "legal" grid is an "empty" floor grid
 *
 * Line 1 -- forbid doors, rubble, seams, walls
 * Line 2 -- forbid normal monsters
 * Line 3 -- forbid the player
 */
#define cave_empty_bold(Y,X) \
    (cave_floor_bold(Y,X) && \
     !(cave[Y][X].m_idx) && \
     !(((Y) == p_ptr->py) && ((X) == p_ptr->px)))


/*
 * Determine if a "legal" grid is an "naked" floor grid
 *
 * Line 1 -- forbid non-floors, non-shallow water & lava -KMW-
 * Line 2 -- forbid normal objects
 * Line 3 -- forbid player/monsters
 */
#define cave_naked_bold(Y,X) \
	(has_flag(&f_info[cave[Y][X].feat], FLAG_FLOOR) && \
	 !has_flag(&f_info[cave[Y][X].feat], FLAG_PERMANENT) && \
	  is_inven_empty(&cave[Y][X].inventory) && \
	  (cave[Y][X].m_idx == 0))

#define cave_naked_bold2(Y,X) \
	(has_flag(&f_info[cave[Y][X].feat], FLAG_FLOOR) && \
	  is_inven_empty(&cave[Y][X].inventory) && \
	  (cave[Y][X].m_idx == 0))



/*
 * Determine if a "legal" grid is "permanent"
 *
 * Line 1   -- perma-walls
 * Line 2-3 -- stairs
 * Line 4-5 -- building doors -KMW-
 * Line 6-7 -- shop doors
 */
#define cave_perma_bold(Y,X) \
       (has_flag(&f_info[cave[Y][X].feat], FLAG_PERMANENT))


/*
 * Grid based version of "cave_floor_bold()"
 */
#define cave_floor_grid(C) \
    (has_flag(&f_info[(C)->feat], FLAG_FLOOR))


/*
 * Grid based version of "cave_plain_floor_bold()"
 */
#define cave_plain_floor_grid(C) \
	(has_flag(&f_info[(C)->feat], FLAG_FLOOR) && \
	 !has_flag(&f_info[(C)->feat], FLAG_REMEMBER))


/*
 * Grid based version of "cave_clean_bold()"
 */
#define cave_clean_grid(C) \
    (has_flag(&f_info[(C)->feat], FLAG_FLOOR) && \
     (!flag_used(&(C)->inventory)))

/*
 * Grid based version of "cave_empty_bold()"
 */
#define cave_empty_grid(C) \
    (cave_floor_grid(C) && \
     !((C)->m_idx) && \
     !((C) == &cave[p_ptr->py][p_ptr->px]))

/*
 * Grid based version of "cave_empty_bold()"
 */
#define cave_naked_grid(C) \
    (has_flag(&f_info[(C)->feat], FLAG_FLOOR) && \
     !(flag_used(&(C)->inventory)) && \
     !((C)->m_idx) && \
     !((C) == &cave[p_ptr->py][p_ptr->px]))


/*
 * Grid based version of "cave_perma_bold()"
 */
#define cave_perma_grid(C) \
       (has_flag(&f_info[(C)->feat], FLAG_PERMANENT))



/*
 * Determine if a "legal" grid is within "los" of the player
 *
 * Note the use of comparison to zero to force a "boolean" result
 */
#define player_has_los_bold(Y,X) \
    ((cave[Y][X].info & (CAVE_VIEW)) != 0)



/*
 * Determine if a "legal" grid can be "seen" by the player
 *
 * Note the use of comparison to zero to force a "boolean" result
 */
#define player_can_see_bold(Y,X) \
	((cave[Y][X].info & (CAVE_SEEN)) != 0)



/*
 * Hack -- Prepare to use the "Secure" routines
 */
#if defined(SET_UID) && defined(SECURE)
extern s32b PlayerUID;
# define getuid() PlayerUID
# define geteuid() PlayerUID
#endif



/*** Color constants ***/


/*
 * Angband "attributes" (with symbols, and base (R,G,B) codes)
 *
 * The "(R,G,B)" codes are given in "fourths" of the "maximal" value,
 * and should "gamma corrected" on most (non-Macintosh) machines.
 */
#define TERM_DARK                0  /* 'd' */   /* 0,0,0 */
#define TERM_WHITE               1  /* 'w' */   /* 4,4,4 */
#define TERM_SLATE               2  /* 's' */   /* 2,2,2 */
#define TERM_ORANGE              3  /* 'o' */   /* 4,2,0 */
#define TERM_RED                 4  /* 'r' */   /* 3,0,0 */
#define TERM_GREEN               5  /* 'g' */   /* 0,2,1 */
#define TERM_BLUE                6  /* 'b' */   /* 0,0,4 */
#define TERM_UMBER               7  /* 'u' */   /* 2,1,0 */
#define TERM_L_DARK              8  /* 'D' */   /* 1,1,1 */
#define TERM_L_WHITE             9  /* 'W' */   /* 3,3,3 */
#define TERM_VIOLET             10  /* 'v' */   /* 4,0,4 */
#define TERM_YELLOW             11  /* 'y' */   /* 4,4,0 */
#define TERM_L_RED              12  /* 'R' */   /* 4,0,0 */
#define TERM_L_GREEN            13  /* 'G' */   /* 0,4,0 */
#define TERM_L_BLUE             14  /* 'B' */   /* 0,4,4 */
#define TERM_L_UMBER            15  /* 'U' */   /* 3,2,1 */


/*** Graphics constants ***/

/*
 * Possible values of graphics_mode
 * Good only when use_graphics is set to TRUE
 * Set by reset_visuals() and used by map_info()
 */
#define GRAPHICS_NONE    0
#define GRAPHICS_UNKNOWN 1
#define GRAPHICS_IBM     2
#define GRAPHICS_ISO     3
#define GRAPHICS_8X8     4
#define GRAPHICS_16X16   5
#define GRAPHICS_32X32   6


/*** Sound constants ***/


/*
 * Mega-Hack -- some primitive sound support (see "main-win.c")
 *
 * Some "sound" constants for "Term_xtra(TERM_XTRA_SOUND, val)"
 */
#define SOUND_HIT        1
#define SOUND_MISS       2
#define SOUND_FLEE       3
#define SOUND_DROP       4
#define SOUND_KILL       5
#define SOUND_LEVEL      6
#define SOUND_DEATH      7
#define SOUND_STUDY      8
#define SOUND_TELEPORT   9
#define SOUND_SHOOT     10
#define SOUND_QUAFF     11
#define SOUND_ZAP       12
#define SOUND_WALK      13
#define SOUND_TPOTHER   14
#define SOUND_HITWALL   15
#define SOUND_EAT       16
#define SOUND_STORE1    17
#define SOUND_STORE2    18
#define SOUND_STORE3    19
#define SOUND_STORE4    20
#define SOUND_DIG       21
#define SOUND_OPENDOOR  22
#define SOUND_SHUTDOOR  23
#define SOUND_TPLEVEL   24
#define SOUND_SCROLL	25
#define SOUND_BUY	    26
#define SOUND_SELL	    27
#define SOUND_WARN	    28
#define SOUND_ROCKET    29 /* Somebody's shooting rockets */
#define SOUND_N_KILL    30 /* The player kills a non-living/undead monster */
#define SOUND_U_KILL    31 /* The player kills a unique */
#define SOUND_QUEST     32 /* The player has just completed a quest */
#define SOUND_HEAL      33 /* The player was healed a little bit */
#define SOUND_X_HEAL    34 /* The player was healed full health */
#define SOUND_BITE      35 /* A monster bites you */
#define SOUND_CLAW      36 /* A monster claws you */
#define SOUND_M_SPELL   37 /* A monster casts a miscellaneous spell */
#define SOUND_SUMMON    38 /* A monster casts a summoning spell  */
#define SOUND_BREATH    39 /* A monster breathes */
#define SOUND_BALL      40 /* A monster casts a ball / bolt spell */
#define SOUND_M_HEAL    41 /* A monster heals itself somehow */
#define SOUND_ATK_SPELL 42 /* A monster casts a misc. offensive spell */
#define SOUND_EVIL      43 /* Something nasty has just happened! */
#define SOUND_TOUCH     44 /* A monster touches you */
#define SOUND_STING     45 /* A monster stings you */
#define SOUND_CRUSH     46 /* A monster crushes / envelopes you */
#define SOUND_SLIME     47 /* A monster drools/spits/etc on you */
#define SOUND_WAIL      48 /* A monster wails */
#define SOUND_WINNER    49 /* Just won the game! */
#define SOUND_FIRE      50 /* An item was burned  */
#define SOUND_ACID      51 /* An item was destroyed by acid */
#define SOUND_ELEC      52 /* An item was destroyed by electricity */
#define SOUND_COLD      53 /* An item was shattered */
#define SOUND_ILLEGAL   54 /* Illegal command attempted */
#define SOUND_FAIL      55 /* Fail to get a spell off / activate an item */
#define SOUND_WAKEUP    56 /* A monster wakes up */
#define SOUND_INVULN    57 /* Invulnerability! */
#define SOUND_FALL      58 /* Falling through a trapdoor... */
#define SOUND_PAIN      59 /* A monster is in pain! */
#define SOUND_DESTITEM  60 /* An item was destroyed by misc. means */
#define SOUND_MOAN      61 /* A monster makes a moan/beg/insult attack */
#define SOUND_SHOW      62 /* A monster makes a "show" attack */
#define SOUND_UNUSED    63 /* (no sound for gaze attacks) */
#define SOUND_EXPLODE   64 /* Something (or somebody) explodes */

/*
 * Mega-Hack -- maximum known sounds
 */
#define SOUND_MAX 65



/*** Hack ***/


/*
 * Hack -- attempt to reduce various values
 */
#ifdef ANGBAND_LITE
# undef MACRO_MAX
# define MACRO_MAX      128
# undef QUARK_MAX
# define QUARK_MAX      128
# undef MESSAGE_MAX
# define MESSAGE_MAX    128
# undef MESSAGE_BUF
# define MESSAGE_BUF    4096
#endif

/*
 * Road flags
 */
#define ROAD_NORTH	1
#define ROAD_SOUTH	2
#define ROAD_EAST	4
#define ROAD_WEST	8

/*
 * Quest status
 */
#define QUEST_STATUS_IGNORED         -1
#define QUEST_STATUS_UNTAKEN         0
#define QUEST_STATUS_TAKEN           1
#define QUEST_STATUS_COMPLETED       2
#define QUEST_STATUS_REWARDED        3
#define QUEST_STATUS_FAILED          4
#define QUEST_STATUS_FINISHED        5
#define QUEST_STATUS_FAILED_DONE     6

/*
 * Music songs
 */
#define MUSIC_NONE              0
#define MUSIC_SLOW              1
#define MUSIC_CONF              2
#define MUSIC_STUN              3
#define MUSIC_LIFE              4
#define MUSIC_MIND              5
#define MUSIC_LITE              6
#define MUSIC_FURY              7
#define MUSIC_AWARE             8
#define MUSIC_ID                9
#define MUSIC_ILLUSION          10
#define MUSIC_WALL              11
#define MUSIC_RESIST            12
#define MUSIC_TIME              13
#define MUSIC_BETWEEN           14
#define MUSIC_CHARME            15
#define MUSIC_VIBRA             16
#define MUSIC_HOLY              17
#define MUSIC_HIDE              18
#define MUSIC_LIBERTY           19
#define MUSIC_RAISE             20
#define MUSIC_SHADOW            21
#define MUSIC_STAR_ID           22

#define MAX_MUSIC               23
#define MAX_MUSICS              11

/*
 * Defines of the different dungeon types
 */
#define DUNGEON_WILDERNESS      0
#define DUNGEON_VOID            11

/* Max depth of each dungeon(max_depth - min_depth) */
#define MAX_DUNGEON_DEPTH       128

#define DUNGEON_MODE_NONE       0
#define DUNGEON_MODE_AND        1
#define DUNGEON_MODE_NAND       2
#define DUNGEON_MODE_OR         3
#define DUNGEON_MODE_NOR        4


/*
 * Returns the dungeon level or the feat,
 * if the player is not in a dungeon
 */
#define level_or_feat(DTYPE, DLEVEL) \
	((DTYPE) == DUNGEON_WILDERNESS ? \
		wild_map[p_ptr->wilderness_y][p_ptr->wilderness_x].feat : \
		(DLEVEL) )


/*
 * Various class dependant defines
 */
#define CLASS_NONE              0
#define CLASS_MANA_PATH         1
#define CLASS_CANALIZE_MANA     2
#define CLASS_WINDS_MANA        3

#define CLASS_MANA_PATH_ERASE           0x0001
#define CLASS_FLOOD_LEVEL               0x0002
#define CLASS_CANALIZE_MANA_EXTRA       0x0004
#define CLASS_UNDEAD                    0x0008
#define CLASS_ANTIMAGIC                 0x0010
#define CLASS_LEGS                      0x0020
#define CLASS_ARMS                      0x0040
#define CLASS_WALL                      0x0080

/*
 * Automatic note taking types
 */
#define NOTE_BIRTH		1
#define NOTE_WINNER		2
#define NOTE_SAVE_GAME		3
#define NOTE_ENTER_DUNGEON	4

/*
 * Player monsters & ghost defines
 * NO MORE USED but for savefile compatibility
 */
#define GHOST_R_IDX_HEAD        967
#define GHOST_R_IDX_TAIL        977
#define MAX_GHOSTS              (GHOST_R_IDX_TAIL - GHOST_R_IDX_HEAD)

/* Stores/buildings defines */
#define STORE_HATED     0
#define STORE_LIKED     1
#define STORE_NORMAL    2

/* Pseudo-id defines */
#define SENSE_NONE                      0
#define SENSE_CURSED			1
#define SENSE_AVERAGE			2
#define SENSE_GOOD_LIGHT		3
#define SENSE_GOOD_HEAVY		4
#define SENSE_EXCELLENT			5
#define SENSE_WORTHLESS			6
#define SENSE_TERRIBLE			7
#define SENSE_SPECIAL			8
#define SENSE_BROKEN			9
#define SENSE_UNCURSED			10

/* Wilderness map related */
#define WILDERNESS_SEE_RADIUS   3       /* The amount of wilderness seen around the player */

/* Ego monsters defines */
#define MEGO_CHAR_ANY           127
#define MEGO_ADD                0
#define MEGO_SUB                1
#define MEGO_FIX                2
#define MEGO_PRC                3

#define MEGO_CHANCE             18      /* % chances of getting ego monsters */

#define race_inf(m_ptr) (((m_ptr)->sr_ptr) ? (m_ptr)->sr_ptr : race_info_idx((m_ptr)->r_idx, (m_ptr)->ego))

/*
 * Used (or should be) by various functions and tables needing access to
 * single bits
 */
#define BIT(x) (1L << (x))

/* Town defines */
#define TOWN_RANDOM     20              /* First random town */
#define TOWN_DUNGEON    4               /* Maximun number of towns per dungeon */
#define TOWN_CHANCE     50              /* Chance of 1 town */

/*
 * Powers (mutation, activations, ...)
 */
#define PWR_INCARNATE                  0
#define POWER_MAX_INIT                 1

/*
 * Quest constants
 */
#define MAX_MON_QUEST       10
#define MAX_ITEM_QUEST       5

#define MAX_RANDOM_QUEST    99

#define QUEST_NULL              0
#define MAX_Q_IDX_INIT          1

#define MAX_PLOTS               1

/*
 * Hooks
 */
enum {
	HOOK_MONSTER_DEATH,
	HOOK_MONSTER_REMOVED,
	HOOK_OPEN_PRE,
	HOOK_OPEN_POST,
	HOOK_CLOSE_PRE,
	HOOK_CLOSE_POST,
	HOOK_GEN_QUEST,
	HOOK_END_TURN,
	HOOK_FEELING,
	HOOK_NEW_MONSTER_PRE,
	HOOK_NEW_MONSTER_POST,
	HOOK_CREATE_DROP,
	HOOK_GEN_LEVEL,
	HOOK_BUILD_ROOM1,
	HOOK_NEW_LEVEL,
	HOOK_QUEST_FINISH,
	HOOK_QUEST_FAIL,
	HOOK_GIVE_PRE,
	HOOK_GIVE_POST,
	HOOK_CHAR_DUMP,
	HOOK_INIT_QUEST,
	HOOK_WILD_GEN,
	HOOK_WILD_GEN_MON,
	HOOK_DROP_PRE,
	HOOK_DROP_POST,
	HOOK_DROPPED_NEAR,
	HOOK_IDENTIFY_POST,
	HOOK_MOVE_PRE_DIR,
	HOOK_MOVE_PRE,
	HOOK_MOVE_OK,
	HOOK_MOVE_POST,
	HOOK_STAY_POST,
	HOOK_WILD_SMALL_MOVE_POST,
	HOOK_WILD_LARGE_NEW_AREA_PRE,
	HOOK_WILD_LARGE_NEW_AREA_POST,
	HOOK_STAIR_PRE,
	HOOK_STAIR_DO,
	HOOK_STAIR_POST,
	HOOK_HIT_WALL,
	HOOK_MONSTER_AI_TARGET,
	HOOK_MONSTER_AI_MOVE,
	HOOK_PLAYER_LEVEL,
	HOOK_WIELD_PRE,
	HOOK_WIELD_INFO,
	HOOK_WIELD_POST,
	HOOK_INIT,
	HOOK_CALC_BONUS,
	HOOK_CALC_POWERS,
	HOOK_KEYPRESS,
	HOOK_KEYPRESS_UNKNOWN,
	HOOK_CHAT,
	HOOK_MON_SPEAK,
	HOOK_MKEY,
	HOOK_MKEY_HIDE,
	HOOK_BIRTH_OBJECTS,
	HOOK_ACTIVATE_DESC,
	HOOK_INIT_GAME,
	HOOK_ACTIVATE_POWER,
	HOOK_ITEM_NAME,
	HOOK_SAVE_GAME,
	HOOK_LOAD_GAME,
	HOOK_LEVEL_REGEN,
	HOOK_LEVEL_END_GEN,
	HOOK_BUILDING_ACTION,
	HOOK_PROCESS_WORLD,
	HOOK_PROCESS_WORLD_WILD,
	HOOK_PROCESS_WORLD_NON_WILD,
	HOOK_WIELD_SLOT,
	HOOK_STORE_STOCK,
	HOOK_STORE_BUY,
	HOOK_GEN_LEVEL_BEGIN,
	HOOK_GEN_LEVEL_AFTER_LOAD,
	HOOK_GET_PRE,
	HOOK_GET_POST,
	HOOK_REDRAW,
	HOOK_RECALC_SKILLS,
	HOOK_ENTER_DUNGEON,
	HOOK_ENTERED_DUNGEON,
	HOOK_DIE_PRE,
	HOOK_DIE_POST,
	HOOK_CALC_HP,
	HOOK_DAM_COLOR,
	HOOK_DAM_EXEC,
	HOOK_PROJECT_P_PRE_LUA,
	HOOK_PROJECT_P_POST_LUA,
	HOOK_CALC_MANA,
	HOOK_LOAD_GAME_END,
	HOOK_SAVE_GAME_END,
	HOOK_RECALL,
	HOOK_FOLLOW_GOD,
	HOOK_SACRIFICE_GOD,
	HOOK_BODY_PARTS,
	HOOK_APPLY_MAGIC,
	HOOK_PLAYER_EXP,
	HOOK_BIRTH,
	HOOK_CALC_LITE,
	HOOK_LEARN_ABILITY,
	HOOK_GAME_START,
	HOOK_TAKEOFF_PRE,
	HOOK_TAKEOFF_POST,
	HOOK_CALC_WEIGHT,
	HOOK_FORBID_TRAVEL,
	HOOK_SAVE_REGISTER,
	HOOK_FLAG_GETTER,
	HOOK_OBJECT_DESC,
	HOOK_OBJECT_VALUE,
	HOOK_DEBUG_COMMAND,
	HOOK_LEVEL_LOOP,
	HOOK_ITEM_NAME_INSERT,
	HOOK_INFO_DATA_LOADED,
	HOOK_CALC_BONUS_END,
	HOOK_MODULE_SCREEN,
	HOOK_TARGET,
	HOOK_MONSTER_LEVEL,
	HOOK_OBJECT_SIMILAR,
	HOOK_OBJECT_ABSORB,
	HOOK_OBJECT_UNABSORB,
	HOOK_PIETY_CHANGE,
	HOOK_PLAYER_CAN_ENTER,
	HOOK_DESTROY_PRE,
	HOOK_DESTROY_POST,
	HOOK_PLAYER_DESTROY_PRE,
	HOOK_PLAYER_DESTROY_POST,
	HOOK_DO_DROP_CORPSE,
	HOOK_CORPSE_CREATE_PRE,
	HOOK_CORPSE_CREATE_POST,
	HOOK_PLAYER_REGEN,
	HOOK_INIT_DONE,
	HOOK_DISTURB,
	HOOK_OBJECT_LEVEL_PRE,
	HOOK_OBJECT_LEVEL_DO,
	HOOK_OBJECT_LEVEL_POST,
	HOOK_MONSTER_TAKE_HIT,
	HOOK_REPEAT_KEY_CHAIN_DESTROY,
	HOOK_PLAYER_USED_ENERGY,
	HOOK_WILD_LARGE_CUSTOM_GENERATOR,
	HOOK_WILD_LARGE_TWEAK_GENERATOR,
	HOOK_ALTER_GRID,
	HOOK_BODY_CHANGE_PRE,
	HOOK_BODY_CHANGE,
	HOOK_BODY_CHANGE_POST,
	HOOK_MON_CHANGE_FACTION_PRE,
	HOOK_MON_CHANGE_FACTION_POST,
	HOOK_NEW_NEST,
	HOOK_NEW_PIT,
	HOOK_NEST_PIT_POST,
	HOOK_MONSTER_FORBID,
	MAX_HOOKS
};



#define HOOK_TYPE_C             0
#define HOOK_TYPE_LUA           1

/*
 * Defines for loadsave.c
 * Why 3 and 7? So if it's uninitialized, the code will be able to catch it, as
 * 0 is an invalid flag. Also, having them apart means that it being accidentally
 * modified will also result in an invalid value -- Improv
 */
#define LS_LOAD 3
#define LS_SAVE 7

/*
 * Special weapon effects
 */
#define SPEC_POIS               0x00000001L
#define SPEC_CUT                0x00000002L

/*
 * Ambushes in the wild
 */
#define AMBUSH_RACE             1
#define AMBUSH_MIX              2

/*
 * Macro trigger
 */
#define MAX_MACRO_MOD 12
#define MAX_MACRO_TRIG 200


/*
 * Skills !
 */
#define SKILL_EXCLUSIVE         9999            /* Flag to tell exclusive skills */

#define MAX_MELEE               3

#define ACTIVATE_SKILL		0
#define BROWSE_SKILL		1
#define MAX_SKILL_ACTION	2


/*
 * Player specialities, should be external but ti would be a mess
 */
#define MAX_SPEC                20


/*
 * Borders between different degrees of resist.
 */
#define RESB_HURT       -1
#define RESB_NORMAL     0
#define RESB_RES_L      60
#define RESB_RES        85
#define RESB_RES_H      99
#define RESB_IMMUNE     100

/*
 * Monster memory classes
 */

#define RT_NONE         0
#define RT_MISC         1
#define RT_RESIST       2
#define RT_SPELL        3
#define RT_BLOWS        4
#define RT_MAX          5

/*
 * Autonote types. Used to avoid repeating the code for all
 * the messages in project_m, such as "it resists".
 */

#define AN_NONE                  0
#define AN_NORMAL                1
#define AN_AFFECTED              2
#define AN_DISPEL                3
#define AN_DISINTEGRATE          4

/*
 * Command numbers for do_cmd_cli().
 *
 * As the user is not intended to have a way to enter these codes directly
 * (doing so isn't harmful, but these codes are not intended as mnemonics),
 * only codes in the range 0xE000 - 0xF8FF (the private area of Unicode 3.0)
 * should be used.
 *
 * In addition, values at the lower end of this range are preferred as the upper
 * end may have a system-specific encoding
 */
#define CMD_CLI_HELP	-8192
#define CMD_IRC_CONNECT	-8191
#define CMD_IRC_CHAT	-8190
#define CMD_IRC_DISCON	-8189
#define CMD_SHOW_TIME	-8188
#define CMD_SHOW_SKILL	-8187
#define CMD_DUMP_HTML	-8186
#define CMD_MACRO    	-8185
#define CMD_QUEST    	-8184
#define CMD_SHOW_ABILITIES -8182

#define CLI_MAX	512


/*
 * The various winner state
 */
#define WINNER_NORMAL           1
#define WINNER_ULTRA            2

/*
 * The new way to store intrinsics
 */
#define intrinsic(n)           \
	flag_get(&p_ptr->intrinsic, FLAG_##n)

#define set_intrinsic(n, v)           \
	flag_set(&p_ptr->intrinsic, FLAG_##n, v)

#define inc_intrinsic(n, v)           \
	flag_set(&p_ptr->intrinsic, FLAG_##n, flag_get(&p_ptr->intrinsic, FLAG_##n) + v)

/*
 * Redirect some function names
 */
#define fprintf my_fprintf
#define fgets my_physfs_fgets
#define fputc my_physfs_fputc
#define fgetc my_physfs_fgetc

/*
 * The new way to store resists
 */
#define resist_get(r, n)           \
	flag_get(r, n)

/*
 * Stats accessors
 */
#define get_stat(st, typ) \
	flag_get(&p_ptr->stat_##typ, st)
#define set_stat(st, typ, val) \
	flag_set(&p_ptr->stat_##typ, st, val)
#define add_stat(st, typ, val) \
	flag_set(&p_ptr->stat_##typ, st, get_stat(st, typ) + val)

/*
 * Monster accessor
 */
#define get_monster(i) (flag_get_monster(&monst_list, i))

/*
 * Size of array of recently placed monsters.
 */
#define PLACED_MONSTERS_MAX 256
