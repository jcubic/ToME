/*
 * Automatic cache load/save generated by Gel(Gema+Lua)
 */
#include "angband.h"
#include "lua.h"
#include "lualib.h"
#include "lauxlib.h"
#include "tolua.h"
#include "lobject.h"

#define VOID_C_FREE(P,N,T) (void)C_FREE(P,N,T)
#define VOID_FREE(P,T) (void)FREE(P,T)

extern lua_State* L;

/* Checks if file needs recompilation */
static bool has_reloaded_some = FALSE;
static bool must_reload_cache(char *src, char *obj)
{
	char buf_src[1024];
	char buf_obj[1024];

	path_build(buf_obj, 1024, TENGINE_DIR_RAW, "registry.raw");

	/* If the registry file is missing, we must regenerate anyway */
	if (!file_exist(buf_obj))
	{
		/* Make sure the registry will be regenerated if we changed something */
		has_reloaded_some = TRUE;
		return (4);
	}

	path_build(buf_src, 1024, TENGINE_DIR_DATA, src);
	path_build(buf_obj, 1024, TENGINE_DIR_RAW, obj);

	/* Access stats on source file */
	if (!file_exist(buf_src))
	{
		/* Make sure the registry will be regenerated if we changed something */
		has_reloaded_some = TRUE;
		return (1);
	}

	/* Access stats on object file */
	if (!file_exist(buf_obj))
	{
		/* Make sure the registry will be regenerated if we changed something */
		has_reloaded_some = TRUE;
		return (2);
	}

	/* Ensure text file is not newer than raw file */
	if (PHYSFS_getLastModTime(buf_src) > PHYSFS_getLastModTime(buf_obj))
	{
		/* Make sure the registry will be regenerated if we changed something */
		has_reloaded_some = TRUE;
		return (3);
	}

	return (FALSE);
}

static PHYSFS_file *open_raw_cache(cptr name, char *mode)
{
	PHYSFS_file *fff;
	char buf[1024];

	path_build(buf, 1024, TENGINE_DIR_RAW, name);

	/* Open the file */
	fff = my_fopen(buf, mode);

	/* Sets the stream to use by the load/save functions */
	set_loadsave_stream(fff);

	return fff;
}

/*
 * This file tells the gel parser the various fields
 * of the various structures to generate caching and lua loading
 * functions for.
 * SAVE: lines have the following format:
 * 
 */

static void cache_loadsave_ability_type(ability_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->desc), flag);
	{ s32b i; for (i = 0; i < MAX_SKILL_ACTION; i++) do_string_nolen((char**)&(s->action_desc[i]), flag); }
	{ s32b i; for (i = 0; i < MAX_SKILL_ACTION; i++) do_s16b(&(s->action_mkey[i]), flag); }
	do_s16b(&(s->cost), flag);
	{ s32b i; for (i = 0; i < 10; i++) do_s16b(&(s->skills[i]), flag); }
	{ s32b i; for (i = 0; i < 10; i++) do_s16b(&(s->skill_levels[i]), flag); }
	{ s32b i; for (i = 0; i < 6; i++) do_s16b(&(s->stat[i]), flag); }
	{ s32b i; for (i = 0; i < 10; i++) do_s16b(&(s->need_abilities[i]), flag); }
	{ s32b i; for (i = 0; i < 10; i++) do_s16b(&(s->forbid_abilities[i]), flag); }
	do_s32b(&(s->allow), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_object_kind(object_kind *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_byte(&(s->tval), flag);
	do_byte(&(s->sval), flag);
	do_s16b(&(s->to_h), flag);
	do_s16b(&(s->to_d), flag);
	do_s16b(&(s->to_a), flag);
	do_s16b(&(s->ac), flag);
	do_byte(&(s->dd), flag);
	do_byte(&(s->ds), flag);
	do_s32b(&(s->weight), flag);
	do_s32b(&(s->cost), flag);
	do_flags(&(s->flags), flag);
	{ s32b i; for (i = 0; i < 4; i++) do_byte(&(s->locale[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_byte(&(s->chance[i]), flag); }
	do_byte(&(s->level), flag);
	do_byte(&(s->d_attr), flag);
	do_char(&(s->d_char), flag);
	do_byte(&(s->btval), flag);
	do_byte(&(s->bsval), flag);
	do_s16b(&(s->power), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_owner_type(owner_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_s16b(&(s->max_cost), flag);
	do_byte(&(s->max_inflate), flag);
	do_byte(&(s->min_inflate), flag);
	do_byte(&(s->haggle_per), flag);
	do_byte(&(s->insult_max), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_flags(&(s->races[i]), flag); }
	{ s32b i; for (i = 0; i < 2; i++) do_flags(&(s->classes[i]), flag); }
	{ s32b i; for (i = 0; i < 3; i++) do_s16b(&(s->costs[i]), flag); }
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_store_action_type(store_action_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	{ s32b i; for (i = 0; i < 3; i++) do_s16b(&(s->costs[i]), flag); }
	do_char(&(s->letter), flag);
	do_char(&(s->letter_aux), flag);
	do_s32b(&(s->action), flag);
	do_s16b(&(s->action_restr), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_store_info_type(store_info_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_flags(&(s->table), flag);
	do_s16b(&(s->max_obj), flag);
	do_s32b(&(s->buy), flag);
	do_string_nolen((char**)&(s->store_maker), flag);
	do_s16b(&(s->store_make_num), flag);
	{ s32b i; for (i = 0; i < 4; i++) do_u16b(&(s->owners[i]), flag); }
	{ s32b i; for (i = 0; i < 6; i++) do_u16b(&(s->actions[i]), flag); }
	do_byte(&(s->d_attr), flag);
	do_char(&(s->d_char), flag);
	do_byte(&(s->x_attr), flag);
	do_char(&(s->x_char), flag);
	do_flags(&(s->flags), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_skill_type(skill_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->desc), flag);
	{ s32b i; for (i = 0; i < MAX_SKILL_ACTION; i++) do_string_nolen((char**)&(s->action_desc[i]), flag); }
	{ s32b i; for (i = 0; i < MAX_SKILL_ACTION; i++) do_s16b(&(s->action_mkey[i]), flag); }
	do_flags(&(s->action), flag);
	do_s16b(&(s->father), flag);
	do_s16b(&(s->order), flag);
	do_flags(&(s->flags), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}



static void cache_loadsave_monster_race(monster_race *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_u16b(&(s->hdice), flag);
	do_u16b(&(s->hside), flag);
	do_s16b(&(s->ac), flag);
	do_s16b(&(s->sleep), flag);
	do_byte(&(s->aaf), flag);
	do_byte(&(s->speed), flag);
	do_s32b(&(s->mexp), flag);
	do_s32b(&(s->weight), flag);
	do_byte(&(s->freq_inate), flag);
	do_byte(&(s->freq_spell), flag);
	do_flags(&(s->flags), flag);
	do_flags(&(s->spells), flag);
	do_flags(&(s->blow), flag);
	do_flags(&(s->body_parts), flag);
	do_byte(&(s->level), flag);
	do_byte(&(s->rarity), flag);
	do_byte(&(s->d_attr), flag);
	do_char(&(s->d_char), flag);
	do_s16b(&(s->sval), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_rule_type(rule_type *s, s32b flag)
{
	do_byte(&(s->mode), flag);
	do_byte(&(s->percent), flag);
	do_flags(&(s->flags), flag);
	do_flags(&(s->spells), flag);
	{ s32b i; for (i = 0; i < 5; i++) do_char(&(s->r_char[i]), flag); }

}


static void cache_loadsave_dungeon_info_type(dungeon_info_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	{ s32b i; for (i = 0; i < 3; i++) do_char(&(s->short_name[i]), flag); }
	do_string_nolen((char**)&(s->generator), flag);
	do_s16b(&(s->floor1), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_byte(&(s->floor_percent1[i]), flag); }
	do_s16b(&(s->floor2), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_byte(&(s->floor_percent2[i]), flag); }
	do_s16b(&(s->floor3), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_byte(&(s->floor_percent3[i]), flag); }
	do_s16b(&(s->outer_wall), flag);
	do_s16b(&(s->inner_wall), flag);
	do_s16b(&(s->fill_type1), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_byte(&(s->fill_percent1[i]), flag); }
	do_s16b(&(s->fill_type2), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_byte(&(s->fill_percent2[i]), flag); }
	do_s16b(&(s->fill_type3), flag);
	{ s32b i; for (i = 0; i < 2; i++) do_byte(&(s->fill_percent3[i]), flag); }
	do_byte(&(s->fill_method), flag);
	do_s16b(&(s->mindepth), flag);
	do_s16b(&(s->maxdepth), flag);
	do_byte(&(s->min_plev), flag);
	do_s16b(&(s->min_m_alloc_level), flag);
	do_s16b(&(s->max_m_alloc_chance), flag);
	do_flags(&(s->flags), flag);
	do_s16b(&(s->size_x), flag);
	do_s16b(&(s->size_y), flag);
	{ s32b i; for (i = 0; i < 5; i++) cache_loadsave_rule_type(&(s->rules[i]), flag); }
	{ s32b i; for (i = 0; i < 100; i++) do_byte(&(s->rule_percents[i]), flag); }
	do_s16b(&(s->ix), flag);
	do_s16b(&(s->iy), flag);
	do_s16b(&(s->ox), flag);
	do_s16b(&(s->oy), flag);
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_dice[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_side[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_frequency[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_type[i]), flag); }
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_feature_type(feature_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_string_nolen((char**)&(s->block), flag);
	do_s32b(&(s->can_enter), flag);
	do_s16b(&(s->mimic), flag);
	do_flags(&(s->flags), flag);
	do_byte(&(s->d_attr), flag);
	do_char(&(s->d_char), flag);
	{ s32b i; for (i = 0; i < 7; i++) do_byte(&(s->shimmer[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_dice[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_side[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_frequency[i]), flag); }
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->d_type[i]), flag); }
	do_s16b(&(s->priority), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_player_descriptor(player_descriptor *s, s32b flag)
{
	do_s16b(&(s->id), flag);
	do_string_nolen((char**)&(s->type), flag);
	do_string_nolen((char**)&(s->title), flag);
	do_string_nolen((char**)&(s->desc), flag);
	do_byte(&(s->place), flag);
	do_flags(&(s->adj), flag);
	do_char(&(s->luck), flag);
	do_s16b(&(s->mana), flag);
	do_s16b(&(s->blow_num), flag);
	do_s16b(&(s->blow_wgt), flag);
	do_s16b(&(s->blow_mul), flag);
	do_s16b(&(s->extra_blows), flag);
	do_s16b(&(s->dis), flag);
	do_s16b(&(s->dev), flag);
	do_s16b(&(s->sav), flag);
	do_s16b(&(s->stl), flag);
	do_s16b(&(s->srh), flag);
	do_s16b(&(s->fos), flag);
	do_s16b(&(s->thn), flag);
	do_s16b(&(s->thb), flag);
	do_byte(&(s->mhp), flag);
	do_u16b(&(s->exp), flag);
	do_byte(&(s->b_age), flag);
	do_byte(&(s->m_age), flag);
	do_byte(&(s->m_b_ht), flag);
	do_byte(&(s->m_m_ht), flag);
	do_byte(&(s->m_b_wt), flag);
	do_byte(&(s->m_m_wt), flag);
	do_byte(&(s->f_b_ht), flag);
	do_byte(&(s->f_m_ht), flag);
	do_byte(&(s->f_b_wt), flag);
	do_byte(&(s->f_m_wt), flag);
	do_byte(&(s->infra), flag);
	do_flags(&(s->choice), flag);
	{ s32b i; for (i = 0; i < 4; i++) do_s16b(&(s->powers[i]), flag); }
	do_flags(&(s->body_parts), flag);
	do_string_nolen((char**)&(s->chart), flag);
	do_flags(&(s->flags), flag);
	{ s32b i; for (i = 0; i < PY_MAX_LEVEL + 1; i++) do_flags(&(s->oflags[i]), flag); }
	do_flags(&(s->skill_base), flag);
	do_flags(&(s->skill_mod), flag);
	do_flags(&(s->objects), flag);
	do_flags(&(s->abilities), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}

static void cache_loadsave_vault_type(vault_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_bool(&(s->dynamic), flag);
	do_byte(&(s->typ), flag);
	do_byte(&(s->rat), flag);
	do_byte(&(s->hgt), flag);
	do_byte(&(s->wid), flag);
	do_s16b(&(s->lvl), flag);
	do_byte(&(s->dun_type), flag);
	{ s32b i; for (i = 0; i < 10; i++) do_s16b(&(s->mon[i]), flag); }
	{ s32b i; for (i = 0; i < 3; i++) do_s16b(&(s->item[i]), flag); }
	do_flags(&(s->flags), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}

static void cache_loadsave___set_type_aux(__set_type_aux *s, s32b flag)
{
	do_s16b(&(s->a_idx), flag);
	{ s32b i; for (i = 0; i < 6; i++) do_flags(&(s->flags[i]), flag); }

}


static void cache_loadsave_set_type(set_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->desc), flag);
	do_byte(&(s->num), flag);
	{ s32b i; for (i = 0; i < 6; i++) cache_loadsave___set_type_aux(&(s->arts[i]), flag); }
	do_string_nolen((char**)&(s->load_script), flag);

}

static void cache_loadsave_monster_ego(monster_ego *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_bool(&(s->before), flag);
	do_flags(&(s->blow), flag);
	do_flags(&(s->blowm_dice), flag);
	do_flags(&(s->blowm_side), flag);
	do_s16b(&(s->hdice), flag);
	do_s16b(&(s->hside), flag);
	do_s16b(&(s->ac), flag);
	do_s16b(&(s->sleep), flag);
	do_s16b(&(s->aaf), flag);
	do_s16b(&(s->speed), flag);
	do_s32b(&(s->mexp), flag);
	do_s32b(&(s->weight), flag);
	do_byte(&(s->freq_inate), flag);
	do_byte(&(s->freq_spell), flag);
	do_flags(&(s->flags), flag);
	do_flags(&(s->hflags), flag);
	do_flags(&(s->mflags), flag);
	do_flags(&(s->nflags), flag);
	do_flags(&(s->msflags), flag);
	do_flags(&(s->nsflags), flag);
	do_bool(&(s->remove_all_spells), flag);
	do_s16b(&(s->level), flag);
	do_s16b(&(s->rarity), flag);
	do_byte(&(s->d_attr), flag);
	do_char(&(s->d_char), flag);
	{ s32b i; for (i = 0; i < 5; i++) do_char(&(s->r_char[i]), flag); }
	{ s32b i; for (i = 0; i < 5; i++) do_char(&(s->nr_char[i]), flag); }
	do_string_nolen((char**)&(s->load_script), flag);

}

static void cache_loadsave_ego_item_type(ego_item_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_bool(&(s->before), flag);
	do_string_nolen((char**)&(s->ego_group), flag);
	{ s32b i; for (i = 0; i < MAX_TVALS_PER_EGO; i++) do_s16b(&(s->tval[i]), flag); }
	{ s32b i; for (i = 0; i < MAX_TVALS_PER_EGO; i++) do_s16b(&(s->min_sval[i]), flag); }
	{ s32b i; for (i = 0; i < MAX_TVALS_PER_EGO; i++) do_s16b(&(s->max_sval[i]), flag); }
	do_flags(&(s->item_kinds_ok), flag);
	do_byte(&(s->rating), flag);
	do_byte(&(s->level), flag);
	do_s16b(&(s->allocation), flag);
	do_s16b(&(s->max_to_h), flag);
	do_s16b(&(s->max_to_d), flag);
	do_s16b(&(s->max_to_a), flag);
	do_u32b(&(s->base_value_pct), flag);
	do_u32b(&(s->value_add), flag);
	{ s32b i; for (i = 0; i < MAX_EGO_FLAG_GROUPS; i++) do_byte(&(s->rar[i]), flag); }
	{ s32b i; for (i = 0; i < MAX_EGO_FLAG_GROUPS; i++) do_flags(&(s->flags[i]), flag); }
	do_flags(&(s->need_flags), flag);
	do_flags(&(s->forbid_flags), flag);
	do_s16b(&(s->power), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}

static void cache_loadsave_artifact_type(artifact_type *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->unknown_name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_byte(&(s->tval), flag);
	do_byte(&(s->sval), flag);
	do_s16b(&(s->d_attr), flag);
	do_s16b(&(s->x_attr), flag);
	do_s16b(&(s->to_h), flag);
	do_s16b(&(s->to_d), flag);
	do_s16b(&(s->to_a), flag);
	do_s16b(&(s->ac), flag);
	do_byte(&(s->dd), flag);
	do_byte(&(s->ds), flag);
	do_s16b(&(s->weight), flag);
	do_s32b(&(s->cost), flag);
	do_flags(&(s->flags), flag);
	do_byte(&(s->level), flag);
	do_byte(&(s->rarity), flag);
	do_s16b(&(s->power), flag);
	do_string_nolen((char**)&(s->load_script), flag);

}

static void cache_loadsave_wilderness_type_info(wilderness_type_info *s, s32b flag)
{
	do_string_nolen((char**)&(s->name), flag);
	do_string_nolen((char**)&(s->text), flag);
	do_u16b(&(s->entrance), flag);
	do_s32b(&(s->wild_x), flag);
	do_s32b(&(s->wild_y), flag);
	do_byte(&(s->road), flag);
	do_s16b(&(s->level), flag);
	do_flags(&(s->flags), flag);
	do_byte(&(s->feat), flag);
	do_byte(&(s->terrain_idx), flag);
	do_char(&(s->d_char), flag);
	do_bool(&(s->rules_set), flag);
	{ s32b i; for (i = 0; i < 100; i++) do_byte(&(s->rule_percents[i]), flag); }
	{ s32b i; for (i = 0; i < 5; i++) cache_loadsave_rule_type(&(s->rules[i]), flag); }
	{ s32b i; for (i = 0; i < MAX_WILD_TERRAIN; i++) do_byte(&(s->terrain[i]), flag); }
/* Feature types for the plasma generator */	do_string_nolen((char**)&(s->load_script), flag);

}


static void cache_loadsave_randart_part_type(randart_part_type *s, s32b flag)
{
	{ s32b i; for (i = 0; i < 20; i++) do_byte(&(s->tval[i]), flag); }
	{ s32b i; for (i = 0; i < 20; i++) do_byte(&(s->min_sval[i]), flag); }
	{ s32b i; for (i = 0; i < 20; i++) do_byte(&(s->max_sval[i]), flag); }
	do_byte(&(s->level), flag);
	do_byte(&(s->rarity), flag);
	do_byte(&(s->mrarity), flag);
	do_s16b(&(s->max_to_h), flag);
	do_s16b(&(s->max_to_d), flag);
	do_s16b(&(s->max_to_a), flag);
	do_s32b(&(s->value), flag);
	do_s16b(&(s->max), flag);
	do_flags(&(s->flags), flag);
	do_flags(&(s->aflags), flag);
	do_s16b(&(s->power), flag);

}

static int cache_wrap_randart_part_type(lua_State *L);
static int cache_wrap_feature_type(lua_State *L);
static int cache_wrap_wilderness_type_info(lua_State *L);
static int cache_wrap_skill_type(lua_State *L);
static int cache_wrap_artifact_type(lua_State *L);
static int cache_wrap_dungeon_info_type(lua_State *L);
static int cache_wrap_vault_type(lua_State *L);
static int cache_wrap_store_info_type(lua_State *L);
static int cache_wrap_store_action_type(lua_State *L);
static int cache_wrap_monster_ego(lua_State *L);
static int cache_wrap_ego_item_type(lua_State *L);
static int cache_wrap_set_type(lua_State *L);
static int cache_wrap_monster_race(lua_State *L);
static int cache_wrap_ability_type(lua_State *L);
static int cache_wrap_object_kind(lua_State *L);
static int cache_wrap___set_type_aux(lua_State *L);
static int cache_wrap_owner_type(lua_State *L);
static int cache_wrap_rule_type(lua_State *L);
static int cache_wrap_player_descriptor(lua_State *L);
static int cache_wrap_randart_part_type(lua_State *L)
{
	s32b i;
	randart_part_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_ra_idx)
	{
		RE_C_MAKE(ra_info, max_ra_idx, 1, randart_part_type);
		max_ra_idx++;
	}
	s = &(ra_info[i]);
	lua_pushstring(L, "tval");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 20; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->tval[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "aflags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->aflags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "max");
	lua_gettable(L, -2);
	s->max = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "power");
	lua_gettable(L, -2);
	s->power = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mrarity");
	lua_gettable(L, -2);
	s->mrarity = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "max_to_h");
	lua_gettable(L, -2);
	s->max_to_h = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "max_to_a");
	lua_gettable(L, -2);
	s->max_to_a = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "min_sval");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 20; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->min_sval[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "max_sval");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 20; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->max_sval[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "value");
	lua_gettable(L, -2);
	s->value = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "max_to_d");
	lua_gettable(L, -2);
	s->max_to_d = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "rarity");
	lua_gettable(L, -2);
	s->rarity = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_randart_part_type(lua_State *L)
{
	max_ra_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(ra_info, max_ra_idx, randart_part_type);
	return 0;
}
errr init_ra_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("items/randarts.lua", "items/randarts.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.ra_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "items/randarts.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_randart_part_type(__ra_num)\n"
			"for i = 1, getn(__ra_info.data) do load_cache_randart_part_type(__ra_info.data[i]) end\n"
			"__ra_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("items/randarts.raw", "wb");
			do_u16b(&max_ra_idx, LS_SAVE);
			for (i = 0; i < max_ra_idx; i++)
				cache_loadsave_randart_part_type(&(ra_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("items/randarts.raw", "rb");
		do_u16b(&max_ra_idx, LS_LOAD);
		C_MAKE(ra_info, max_ra_idx, randart_part_type);
		for (i = 0; i < max_ra_idx; i++)
		{
			/* Load it */
			cache_loadsave_randart_part_type(&(ra_info[i]), LS_LOAD);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__ra_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_feature_type(lua_State *L)
{
	s32b i;
	feature_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_f_idx)
	{
		RE_C_MAKE(f_info, max_f_idx, 1, feature_type);
		max_f_idx++;
	}
	s = &(f_info[i]);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "priority");
	lua_gettable(L, -2);
	s->priority = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_frequency");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_frequency[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "d_type");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_type[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "d_side");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_side[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "d_dice");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_dice[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "can_enter");
	lua_gettable(L, -2);
	s->can_enter = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mimic");
	lua_gettable(L, -2);
	s->mimic = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "shimmer");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 7; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->shimmer[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "block");
	lua_gettable(L, -2);
	s->block = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "d_attr");
	lua_gettable(L, -2);
	s->d_attr = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_char");
	lua_gettable(L, -2);
	s->d_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_feature_type(lua_State *L)
{
	max_f_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(f_info, max_f_idx, feature_type);
	return 0;
}
errr init_f_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("dungeon/features.lua", "dungeon/features.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.f_info] = {}");

		/* Load the core data */
		tome_dofile_anywhere(TENGINE_DIR_ENGINE, "features.lua", TRUE, FALSE);		
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "dungeon/features.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_feature_type(__f_num)\n"
			"for i = 1, getn(__f_info.data) do load_cache_feature_type(__f_info.data[i]) end\n"
			"__f_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("dungeon/features.raw", "wb");
			do_u16b(&max_f_idx, LS_SAVE);
			for (i = 0; i < max_f_idx; i++)
				cache_loadsave_feature_type(&(f_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("dungeon/features.raw", "rb");
		do_u16b(&max_f_idx, LS_LOAD);
		C_MAKE(f_info, max_f_idx, feature_type);
		for (i = 0; i < max_f_idx; i++)
		{
			/* Load it */
			cache_loadsave_feature_type(&(f_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(f_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__f_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_wilderness_type_info(lua_State *L)
{
	s32b i;
	wilderness_type_info *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_wf_idx)
	{
		RE_C_MAKE(wf_info, max_wf_idx, 1, wilderness_type_info);
		max_wf_idx++;
	}
	s = &(wf_info[i]);
	lua_pushstring(L, "rules");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 5; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		lua_pushuserdata(L, &(s->rules[i])); cache_wrap_rule_type(L); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "rules_set");
	lua_gettable(L, -2);
	s->rules_set = (bool)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "wild_y");
	lua_gettable(L, -2);
	s->wild_y = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "entrance");
	lua_gettable(L, -2);
	s->entrance = (u16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_char");
	lua_gettable(L, -2);
	s->d_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "rule_percents");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 100; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->rule_percents[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "road");
	lua_gettable(L, -2);
	s->road = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "feat");
	lua_gettable(L, -2);
	s->feat = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "terrain");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_WILD_TERRAIN; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->terrain[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "terrain_idx");
	lua_gettable(L, -2);
	s->terrain_idx = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "wild_x");
	lua_gettable(L, -2);
	s->wild_x = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_wilderness_type_info(lua_State *L)
{
	max_wf_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(wf_info, max_wf_idx, wilderness_type_info);
	return 0;
}
errr init_wf_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("wild/terrain.lua", "wild/terrain.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.wf_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "wild/terrain.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_wilderness_type_info(__wf_num)\n"
			"for i = 1, getn(__wf_info.data) do load_cache_wilderness_type_info(__wf_info.data[i]) end\n"
			"__wf_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("wild/terrain.raw", "wb");
			do_u16b(&max_wf_idx, LS_SAVE);
			for (i = 0; i < max_wf_idx; i++)
				cache_loadsave_wilderness_type_info(&(wf_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("wild/terrain.raw", "rb");
		do_u16b(&max_wf_idx, LS_LOAD);
		C_MAKE(wf_info, max_wf_idx, wilderness_type_info);
		for (i = 0; i < max_wf_idx; i++)
		{
			/* Load it */
			cache_loadsave_wilderness_type_info(&(wf_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(wf_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__wf_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	call_lua("init_wf_info_wildc2i", "()", "");
	/* Success */
	return (0);
}
static int cache_wrap_skill_type(lua_State *L)
{
	s32b i;
	skill_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_s_idx)
	{
		RE_C_MAKE(s_info, max_s_idx, 1, skill_type);
		max_s_idx++;
	}
	s = &(s_info[i]);
	lua_pushstring(L, "action");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->action = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "order");
	lua_gettable(L, -2);
	s->order = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "desc");
	lua_gettable(L, -2);
	s->desc = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "father");
	lua_gettable(L, -2);
	s->father = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "action_mkey");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_SKILL_ACTION; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->action_mkey[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "action_desc");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_SKILL_ACTION; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->action_desc[i] = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_skill_type(lua_State *L)
{
	max_s_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(s_info, max_s_idx, skill_type);
	return 0;
}
errr init_s_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("player/skills.lua", "player/skills.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.s_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "player/skills.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_skill_type(__s_num)\n"
			"for i = 1, getn(__s_info.data) do load_cache_skill_type(__s_info.data[i]) end\n"
			"__s_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("player/skills.raw", "wb");
			do_u16b(&max_s_idx, LS_SAVE);
			for (i = 0; i < max_s_idx; i++)
				cache_loadsave_skill_type(&(s_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("player/skills.raw", "rb");
		do_u16b(&max_s_idx, LS_LOAD);
		C_MAKE(s_info, max_s_idx, skill_type);
		for (i = 0; i < max_s_idx; i++)
		{
			/* Load it */
			cache_loadsave_skill_type(&(s_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(s_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__s_num = %d", i));
	}
	{
		char *load;

		/* Data loaded from a .lua file, need to be written and executed */
		if (test)
		{
			get_lua_var("__s_info.load_script", 's', &load);

			/* Write the cache if requested */
			if (tome_write_raw_files)
				do_string_nolen(&load, LS_SAVE);
		}
		/* Data loaded from a .raw file, need to be read and executed */
		else
		{
			do_string_nolen(&load, LS_LOAD);
		}
		exec_lua(load);
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_artifact_type(lua_State *L)
{
	s32b i;
	artifact_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_a_idx)
	{
		RE_C_MAKE(a_info, max_a_idx, 1, artifact_type);
		max_a_idx++;
	}
	s = &(a_info[i]);
	lua_pushstring(L, "ds");
	lua_gettable(L, -2);
	s->ds = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "cost");
	lua_gettable(L, -2);
	s->cost = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "ac");
	lua_gettable(L, -2);
	s->ac = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "x_attr");
	lua_gettable(L, -2);
	s->x_attr = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "dd");
	lua_gettable(L, -2);
	s->dd = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "sval");
	lua_gettable(L, -2);
	s->sval = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "tval");
	lua_gettable(L, -2);
	s->tval = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "power");
	lua_gettable(L, -2);
	s->power = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "rarity");
	lua_gettable(L, -2);
	s->rarity = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "weight");
	lua_gettable(L, -2);
	s->weight = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "to_h");
	lua_gettable(L, -2);
	s->to_h = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "to_a");
	lua_gettable(L, -2);
	s->to_a = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "to_d");
	lua_gettable(L, -2);
	s->to_d = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_attr");
	lua_gettable(L, -2);
	s->d_attr = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "unknown_name");
	lua_gettable(L, -2);
	s->unknown_name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_artifact_type(lua_State *L)
{
	max_a_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(a_info, max_a_idx, artifact_type);
	return 0;
}
errr init_a_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("items/artifacts.lua", "items/artifacts.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.a_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "items/artifacts.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_artifact_type(__a_num)\n"
			"for i = 1, getn(__a_info.data) do load_cache_artifact_type(__a_info.data[i]) end\n"
			"__a_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("items/artifacts.raw", "wb");
			do_u16b(&max_a_idx, LS_SAVE);
			for (i = 0; i < max_a_idx; i++)
				cache_loadsave_artifact_type(&(a_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("items/artifacts.raw", "rb");
		do_u16b(&max_a_idx, LS_LOAD);
		C_MAKE(a_info, max_a_idx, artifact_type);
		for (i = 0; i < max_a_idx; i++)
		{
			/* Load it */
			cache_loadsave_artifact_type(&(a_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(a_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__a_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_dungeon_info_type(lua_State *L)
{
	s32b i;
	dungeon_info_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_d_idx)
	{
		RE_C_MAKE(d_info, max_d_idx, 1, dungeon_info_type);
		max_d_idx++;
	}
	s = &(d_info[i]);
	lua_pushstring(L, "min_plev");
	lua_gettable(L, -2);
	s->min_plev = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "rules");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 5; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		lua_pushuserdata(L, &(s->rules[i])); cache_wrap_rule_type(L); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "floor_percent1");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->floor_percent1[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "d_type");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_type[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "oy");
	lua_gettable(L, -2);
	s->oy = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "inner_wall");
	lua_gettable(L, -2);
	s->inner_wall = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "fill_percent3");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->fill_percent3[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "d_dice");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_dice[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "iy");
	lua_gettable(L, -2);
	s->iy = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "floor2");
	lua_gettable(L, -2);
	s->floor2 = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "size_x");
	lua_gettable(L, -2);
	s->size_x = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "floor_percent2");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->floor_percent2[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "fill_type1");
	lua_gettable(L, -2);
	s->fill_type1 = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "generator");
	lua_gettable(L, -2);
	s->generator = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "fill_method");
	lua_gettable(L, -2);
	s->fill_method = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "floor_percent3");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->floor_percent3[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "short_name");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 3; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->short_name[i] = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "ox");
	lua_gettable(L, -2);
	s->ox = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "min_m_alloc_level");
	lua_gettable(L, -2);
	s->min_m_alloc_level = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "outer_wall");
	lua_gettable(L, -2);
	s->outer_wall = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "maxdepth");
	lua_gettable(L, -2);
	s->maxdepth = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mindepth");
	lua_gettable(L, -2);
	s->mindepth = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "floor1");
	lua_gettable(L, -2);
	s->floor1 = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "max_m_alloc_chance");
	lua_gettable(L, -2);
	s->max_m_alloc_chance = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "size_y");
	lua_gettable(L, -2);
	s->size_y = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "fill_percent1");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->fill_percent1[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "d_side");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_side[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "floor3");
	lua_gettable(L, -2);
	s->floor3 = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_frequency");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->d_frequency[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "ix");
	lua_gettable(L, -2);
	s->ix = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "rule_percents");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 100; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->rule_percents[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "fill_type3");
	lua_gettable(L, -2);
	s->fill_type3 = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "fill_percent2");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->fill_percent2[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "fill_type2");
	lua_gettable(L, -2);
	s->fill_type2 = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_dungeon_info_type(lua_State *L)
{
	max_d_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(d_info, max_d_idx, dungeon_info_type);
	return 0;
}
errr init_d_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("dungeon/dungeons.lua", "dungeon/dungeons.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.d_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "dungeon/dungeons.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_dungeon_info_type(__d_num)\n"
			"for i = 1, getn(__d_info.data) do load_cache_dungeon_info_type(__d_info.data[i]) end\n"
			"__d_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("dungeon/dungeons.raw", "wb");
			do_u16b(&max_d_idx, LS_SAVE);
			for (i = 0; i < max_d_idx; i++)
				cache_loadsave_dungeon_info_type(&(d_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("dungeon/dungeons.raw", "rb");
		do_u16b(&max_d_idx, LS_LOAD);
		C_MAKE(d_info, max_d_idx, dungeon_info_type);
		for (i = 0; i < max_d_idx; i++)
		{
			/* Load it */
			cache_loadsave_dungeon_info_type(&(d_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(d_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__d_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_vault_type(lua_State *L)
{
	s32b i;
	vault_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_v_idx)
	{
		RE_C_MAKE(v_info, max_v_idx, 1, vault_type);
		max_v_idx++;
	}
	s = &(v_info[i]);
	lua_pushstring(L, "dynamic");
	lua_gettable(L, -2);
	s->dynamic = (bool)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "dun_type");
	lua_gettable(L, -2);
	s->dun_type = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "typ");
	lua_gettable(L, -2);
	s->typ = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "item");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 3; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->item[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "hgt");
	lua_gettable(L, -2);
	s->hgt = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "rat");
	lua_gettable(L, -2);
	s->rat = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "lvl");
	lua_gettable(L, -2);
	s->lvl = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "wid");
	lua_gettable(L, -2);
	s->wid = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mon");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 10; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->mon[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_vault_type(lua_State *L)
{
	max_v_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(v_info, max_v_idx, vault_type);
	return 0;
}
errr init_v_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("dungeon/vaults.lua", "dungeon/vaults.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.v_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "dungeon/vaults.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_vault_type(__v_num)\n"
			"for i = 1, getn(__v_info.data) do load_cache_vault_type(__v_info.data[i]) end\n"
			"__v_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("dungeon/vaults.raw", "wb");
			do_u16b(&max_v_idx, LS_SAVE);
			for (i = 0; i < max_v_idx; i++)
				cache_loadsave_vault_type(&(v_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("dungeon/vaults.raw", "rb");
		do_u16b(&max_v_idx, LS_LOAD);
		C_MAKE(v_info, max_v_idx, vault_type);
		for (i = 0; i < max_v_idx; i++)
		{
			/* Load it */
			cache_loadsave_vault_type(&(v_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(v_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__v_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_store_info_type(lua_State *L)
{
	s32b i;
	store_info_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_st_idx)
	{
		RE_C_MAKE(st_info, max_st_idx, 1, store_info_type);
		max_st_idx++;
	}
	s = &(st_info[i]);
	lua_pushstring(L, "table");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->table = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "x_char");
	lua_gettable(L, -2);
	s->x_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "actions");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 6; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->actions[i] = (u16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "x_attr");
	lua_gettable(L, -2);
	s->x_attr = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_char");
	lua_gettable(L, -2);
	s->d_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_attr");
	lua_gettable(L, -2);
	s->d_attr = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "max_obj");
	lua_gettable(L, -2);
	s->max_obj = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "owners");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->owners[i] = (u16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "store_maker");
	lua_gettable(L, -2);
	s->store_maker = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "store_make_num");
	lua_gettable(L, -2);
	s->store_make_num = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "buy");
	lua_gettable(L, -2);
	s->buy = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_store_info_type(lua_State *L)
{
	max_st_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(st_info, max_st_idx, store_info_type);
	return 0;
}
errr init_st_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("stores/stores.lua", "stores/stores.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.st_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "stores/stores.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_store_info_type(__st_num)\n"
			"for i = 1, getn(__st_info.data) do load_cache_store_info_type(__st_info.data[i]) end\n"
			"__st_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("stores/stores.raw", "wb");
			do_u16b(&max_st_idx, LS_SAVE);
			for (i = 0; i < max_st_idx; i++)
				cache_loadsave_store_info_type(&(st_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("stores/stores.raw", "rb");
		do_u16b(&max_st_idx, LS_LOAD);
		C_MAKE(st_info, max_st_idx, store_info_type);
		for (i = 0; i < max_st_idx; i++)
		{
			/* Load it */
			cache_loadsave_store_info_type(&(st_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(st_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__st_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_store_action_type(lua_State *L)
{
	s32b i;
	store_action_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_ba_idx)
	{
		RE_C_MAKE(ba_info, max_ba_idx, 1, store_action_type);
		max_ba_idx++;
	}
	s = &(ba_info[i]);
	lua_pushstring(L, "costs");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 3; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->costs[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "letter");
	lua_gettable(L, -2);
	s->letter = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "action_restr");
	lua_gettable(L, -2);
	s->action_restr = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "action");
	lua_gettable(L, -2);
	s->action = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "letter_aux");
	lua_gettable(L, -2);
	s->letter_aux = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_store_action_type(lua_State *L)
{
	max_ba_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(ba_info, max_ba_idx, store_action_type);
	return 0;
}
errr init_ba_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("stores/actions.lua", "stores/actions.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.ba_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "stores/actions.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_store_action_type(__ba_num)\n"
			"for i = 1, getn(__ba_info.data) do load_cache_store_action_type(__ba_info.data[i]) end\n"
			"__ba_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("stores/actions.raw", "wb");
			do_u16b(&max_ba_idx, LS_SAVE);
			for (i = 0; i < max_ba_idx; i++)
				cache_loadsave_store_action_type(&(ba_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("stores/actions.raw", "rb");
		do_u16b(&max_ba_idx, LS_LOAD);
		C_MAKE(ba_info, max_ba_idx, store_action_type);
		for (i = 0; i < max_ba_idx; i++)
		{
			/* Load it */
			cache_loadsave_store_action_type(&(ba_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(ba_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__ba_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_monster_ego(lua_State *L)
{
	s32b i;
	monster_ego *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_re_idx)
	{
		RE_C_MAKE(re_info, max_re_idx, 1, monster_ego);
		max_re_idx++;
	}
	s = &(re_info[i]);
	lua_pushstring(L, "sleep");
	lua_gettable(L, -2);
	s->sleep = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "mexp");
	lua_gettable(L, -2);
	s->mexp = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "nr_char");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 5; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->nr_char[i] = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "r_char");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 5; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->r_char[i] = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "before");
	lua_gettable(L, -2);
	s->before = (bool)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "aaf");
	lua_gettable(L, -2);
	s->aaf = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "hflags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->hflags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "weight");
	lua_gettable(L, -2);
	s->weight = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "speed");
	lua_gettable(L, -2);
	s->speed = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "blowm_dice");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->blowm_dice = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "d_char");
	lua_gettable(L, -2);
	s->d_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mflags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->mflags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "ac");
	lua_gettable(L, -2);
	s->ac = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "rarity");
	lua_gettable(L, -2);
	s->rarity = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "hdice");
	lua_gettable(L, -2);
	s->hdice = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "nsflags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->nsflags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "freq_spell");
	lua_gettable(L, -2);
	s->freq_spell = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "freq_inate");
	lua_gettable(L, -2);
	s->freq_inate = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "nflags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->nflags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "hside");
	lua_gettable(L, -2);
	s->hside = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "msflags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->msflags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "blow");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->blow = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "remove_all_spells");
	lua_gettable(L, -2);
	s->remove_all_spells = (bool)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_attr");
	lua_gettable(L, -2);
	s->d_attr = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "blowm_side");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->blowm_side = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_monster_ego(lua_State *L)
{
	max_re_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(re_info, max_re_idx, monster_ego);
	return 0;
}
errr init_re_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("monsters/egos.lua", "monsters/egos.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.re_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "monsters/egos.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_monster_ego(__re_num)\n"
			"for i = 1, getn(__re_info.data) do load_cache_monster_ego(__re_info.data[i]) end\n"
			"__re_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("monsters/egos.raw", "wb");
			do_u16b(&max_re_idx, LS_SAVE);
			for (i = 0; i < max_re_idx; i++)
				cache_loadsave_monster_ego(&(re_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("monsters/egos.raw", "rb");
		do_u16b(&max_re_idx, LS_LOAD);
		C_MAKE(re_info, max_re_idx, monster_ego);
		for (i = 0; i < max_re_idx; i++)
		{
			/* Load it */
			cache_loadsave_monster_ego(&(re_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(re_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__re_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_ego_item_type(lua_State *L)
{
	s32b i;
	ego_item_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_e_idx)
	{
		RE_C_MAKE(e_info, max_e_idx, 1, ego_item_type);
		max_e_idx++;
	}
	s = &(e_info[i]);
	lua_pushstring(L, "max_to_d");
	lua_gettable(L, -2);
	s->max_to_d = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "before");
	lua_gettable(L, -2);
	s->before = (bool)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "min_sval");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_TVALS_PER_EGO; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->min_sval[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "max_sval");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_TVALS_PER_EGO; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->max_sval[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "rating");
	lua_gettable(L, -2);
	s->rating = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "rar");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_EGO_FLAG_GROUPS; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->rar[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "max_to_a");
	lua_gettable(L, -2);
	s->max_to_a = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "forbid_flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->forbid_flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "tval");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_TVALS_PER_EGO; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->tval[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "power");
	lua_gettable(L, -2);
	s->power = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "need_flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->need_flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_EGO_FLAG_GROUPS; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags[i] = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "allocation");
	lua_gettable(L, -2);
	s->allocation = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "value_add");
	lua_gettable(L, -2);
	s->value_add = (u32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "item_kinds_ok");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->item_kinds_ok = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "base_value_pct");
	lua_gettable(L, -2);
	s->base_value_pct = (u32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "max_to_h");
	lua_gettable(L, -2);
	s->max_to_h = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "ego_group");
	lua_gettable(L, -2);
	s->ego_group = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_ego_item_type(lua_State *L)
{
	max_e_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(e_info, max_e_idx, ego_item_type);
	return 0;
}
errr init_e_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("items/egos.lua", "items/egos.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.e_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "items/egos.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_ego_item_type(__e_num)\n"
			"for i = 1, getn(__e_info.data) do load_cache_ego_item_type(__e_info.data[i]) end\n"
			"__e_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("items/egos.raw", "wb");
			do_u16b(&max_e_idx, LS_SAVE);
			for (i = 0; i < max_e_idx; i++)
				cache_loadsave_ego_item_type(&(e_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("items/egos.raw", "rb");
		do_u16b(&max_e_idx, LS_LOAD);
		C_MAKE(e_info, max_e_idx, ego_item_type);
		for (i = 0; i < max_e_idx; i++)
		{
			/* Load it */
			cache_loadsave_ego_item_type(&(e_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(e_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__e_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_set_type(lua_State *L)
{
	s32b i;
	set_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_set_idx)
	{
		RE_C_MAKE(set_info, max_set_idx, 1, set_type);
		max_set_idx++;
	}
	s = &(set_info[i]);
	lua_pushstring(L, "num");
	lua_gettable(L, -2);
	s->num = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "arts");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 6; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		lua_pushuserdata(L, &(s->arts[i])); cache_wrap___set_type_aux(L); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "desc");
	lua_gettable(L, -2);
	s->desc = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_set_type(lua_State *L)
{
	max_set_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(set_info, max_set_idx, set_type);
	return 0;
}
errr init_set_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("items/sets.lua", "items/sets.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.set_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "items/sets.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_set_type(__set_num)\n"
			"for i = 1, getn(__set_info.data) do load_cache_set_type(__set_info.data[i]) end\n"
			"__set_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("items/sets.raw", "wb");
			do_s16b(&max_set_idx, LS_SAVE);
			for (i = 0; i < max_set_idx; i++)
				cache_loadsave_set_type(&(set_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("items/sets.raw", "rb");
		do_s16b(&max_set_idx, LS_LOAD);
		C_MAKE(set_info, max_set_idx, set_type);
		for (i = 0; i < max_set_idx; i++)
		{
			/* Load it */
			cache_loadsave_set_type(&(set_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(set_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__set_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_monster_race(lua_State *L)
{
	s32b i;
	monster_race *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_r_idx)
	{
		RE_C_MAKE(r_info, max_r_idx, 1, monster_race);
		max_r_idx++;
	}
	s = &(r_info[i]);
	lua_pushstring(L, "sleep");
	lua_gettable(L, -2);
	s->sleep = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mexp");
	lua_gettable(L, -2);
	s->mexp = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "ac");
	lua_gettable(L, -2);
	s->ac = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "aaf");
	lua_gettable(L, -2);
	s->aaf = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "weight");
	lua_gettable(L, -2);
	s->weight = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "speed");
	lua_gettable(L, -2);
	s->speed = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_char");
	lua_gettable(L, -2);
	s->d_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "sval");
	lua_gettable(L, -2);
	s->sval = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "hdice");
	lua_gettable(L, -2);
	s->hdice = (u16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "freq_spell");
	lua_gettable(L, -2);
	s->freq_spell = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "freq_inate");
	lua_gettable(L, -2);
	s->freq_inate = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "hside");
	lua_gettable(L, -2);
	s->hside = (u16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "rarity");
	lua_gettable(L, -2);
	s->rarity = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "blow");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->blow = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "body_parts");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->body_parts = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "d_attr");
	lua_gettable(L, -2);
	s->d_attr = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "spells");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->spells = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_monster_race(lua_State *L)
{
	max_r_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(r_info, max_r_idx, monster_race);
	return 0;
}
errr init_r_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("monsters/races.lua", "monsters/races.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.r_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "monsters/races.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_monster_race(__r_num)\n"
			"for i = 1, getn(__r_info.data) do load_cache_monster_race(__r_info.data[i]) end\n"
			"__r_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("monsters/races.raw", "wb");
			do_u16b(&max_r_idx, LS_SAVE);
			for (i = 0; i < max_r_idx; i++)
				cache_loadsave_monster_race(&(r_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("monsters/races.raw", "rb");
		do_u16b(&max_r_idx, LS_LOAD);
		C_MAKE(r_info, max_r_idx, monster_race);
		for (i = 0; i < max_r_idx; i++)
		{
			/* Load it */
			cache_loadsave_monster_race(&(r_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(r_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__r_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_ability_type(lua_State *L)
{
	s32b i;
	ability_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_ab_idx)
	{
		RE_C_MAKE(ab_info, max_ab_idx, 1, ability_type);
		max_ab_idx++;
	}
	s = &(ab_info[i]);
	lua_pushstring(L, "skill_levels");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 10; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->skill_levels[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "need_abilities");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 10; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->need_abilities[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "desc");
	lua_gettable(L, -2);
	s->desc = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "action_desc");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_SKILL_ACTION; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->action_desc[i] = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "allow");
	lua_gettable(L, -2);
	s->allow = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "action_mkey");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < MAX_SKILL_ACTION; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->action_mkey[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "forbid_abilities");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 10; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->forbid_abilities[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "skills");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 10; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->skills[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "stat");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 6; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->stat[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "cost");
	lua_gettable(L, -2);
	s->cost = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_ability_type(lua_State *L)
{
	max_ab_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(ab_info, max_ab_idx, ability_type);
	return 0;
}
errr init_ab_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("player/abilities.lua", "player/abilities.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.ab_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "player/abilities.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_ability_type(__ab_num)\n"
			"for i = 1, getn(__ab_info.data) do load_cache_ability_type(__ab_info.data[i]) end\n"
			"__ab_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("player/abilities.raw", "wb");
			do_u16b(&max_ab_idx, LS_SAVE);
			for (i = 0; i < max_ab_idx; i++)
				cache_loadsave_ability_type(&(ab_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("player/abilities.raw", "rb");
		do_u16b(&max_ab_idx, LS_LOAD);
		C_MAKE(ab_info, max_ab_idx, ability_type);
		for (i = 0; i < max_ab_idx; i++)
		{
			/* Load it */
			cache_loadsave_ability_type(&(ab_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(ab_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__ab_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_object_kind(lua_State *L)
{
	s32b i;
	object_kind *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_k_idx)
	{
		RE_C_MAKE(k_info, max_k_idx, 1, object_kind);
		max_k_idx++;
	}
	s = &(k_info[i]);
	lua_pushstring(L, "ds");
	lua_gettable(L, -2);
	s->ds = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "btval");
	lua_gettable(L, -2);
	s->btval = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "cost");
	lua_gettable(L, -2);
	s->cost = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "ac");
	lua_gettable(L, -2);
	s->ac = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "to_d");
	lua_gettable(L, -2);
	s->to_d = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "dd");
	lua_gettable(L, -2);
	s->dd = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "chance");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->chance[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "level");
	lua_gettable(L, -2);
	s->level = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "d_char");
	lua_gettable(L, -2);
	s->d_char = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "sval");
	lua_gettable(L, -2);
	s->sval = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "tval");
	lua_gettable(L, -2);
	s->tval = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "power");
	lua_gettable(L, -2);
	s->power = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "text");
	lua_gettable(L, -2);
	s->text = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "bsval");
	lua_gettable(L, -2);
	s->bsval = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "to_h");
	lua_gettable(L, -2);
	s->to_h = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "to_a");
	lua_gettable(L, -2);
	s->to_a = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "locale");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->locale[i] = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "d_attr");
	lua_gettable(L, -2);
	s->d_attr = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "weight");
	lua_gettable(L, -2);
	s->weight = (s32b)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_object_kind(lua_State *L)
{
	max_k_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(k_info, max_k_idx, object_kind);
	return 0;
}
errr init_k_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("items/items.lua", "items/items.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.k_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "items/items.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_object_kind(__k_num)\n"
			"for i = 1, getn(__k_info.data) do load_cache_object_kind(__k_info.data[i]) end\n"
			"__k_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("items/items.raw", "wb");
			do_u16b(&max_k_idx, LS_SAVE);
			for (i = 0; i < max_k_idx; i++)
				cache_loadsave_object_kind(&(k_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("items/items.raw", "rb");
		do_u16b(&max_k_idx, LS_LOAD);
		C_MAKE(k_info, max_k_idx, object_kind);
		for (i = 0; i < max_k_idx; i++)
		{
			/* Load it */
			cache_loadsave_object_kind(&(k_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(k_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__k_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap___set_type_aux(lua_State *L)
{
	s32b i;
	__set_type_aux *s = (__set_type_aux*)lua_touserdata(L, -1);
	lua_pop(L, 1);

	/* Avoid silly warning */
	i = 0;

	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 6; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags[i] = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "a_idx");
	lua_gettable(L, -2);
	s->a_idx = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_owner_type(lua_State *L)
{
	s32b i;
	owner_type *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_ow_idx)
	{
		RE_C_MAKE(ow_info, max_ow_idx, 1, owner_type);
		max_ow_idx++;
	}
	s = &(ow_info[i]);
	lua_pushstring(L, "max_cost");
	lua_gettable(L, -2);
	s->max_cost = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "min_inflate");
	lua_gettable(L, -2);
	s->min_inflate = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "classes");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->classes[i] = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "costs");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 3; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->costs[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "races");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 2; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->races[i] = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "insult_max");
	lua_gettable(L, -2);
	s->insult_max = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "haggle_per");
	lua_gettable(L, -2);
	s->haggle_per = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "name");
	lua_gettable(L, -2);
	s->name = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "max_inflate");
	lua_gettable(L, -2);
	s->max_inflate = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_owner_type(lua_State *L)
{
	max_ow_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(ow_info, max_ow_idx, owner_type);
	return 0;
}
errr init_ow_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("stores/owners.lua", "stores/owners.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.ow_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "stores/owners.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_owner_type(__ow_num)\n"
			"for i = 1, getn(__ow_info.data) do load_cache_owner_type(__ow_info.data[i]) end\n"
			"__ow_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("stores/owners.raw", "wb");
			do_u16b(&max_ow_idx, LS_SAVE);
			for (i = 0; i < max_ow_idx; i++)
				cache_loadsave_owner_type(&(ow_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("stores/owners.raw", "rb");
		do_u16b(&max_ow_idx, LS_LOAD);
		C_MAKE(ow_info, max_ow_idx, owner_type);
		for (i = 0; i < max_ow_idx; i++)
		{
			/* Load it */
			cache_loadsave_owner_type(&(ow_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(ow_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__ow_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
static int cache_wrap_rule_type(lua_State *L)
{
	s32b i;
	rule_type *s = (rule_type*)lua_touserdata(L, -1);
	lua_pop(L, 1);

	/* Avoid silly warning */
	i = 0;

	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "r_char");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 5; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->r_char[i] = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "spells");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->spells = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "percent");
	lua_gettable(L, -2);
	s->percent = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mode");
	lua_gettable(L, -2);
	s->mode = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_player_descriptor(lua_State *L)
{
	s32b i;
	player_descriptor *s;
	lua_pushstring(L, "__index__");
	lua_gettable(L, -2);
	i = lua_tonumber(L, -1); lua_pop(L, 1);

	/* Must get bigger? */
	if (i == max_dp_idx)
	{
		RE_C_MAKE(descriptor_info, max_dp_idx, 1, player_descriptor);
		max_dp_idx++;
	}
	s = &(descriptor_info[i]);
	lua_pushstring(L, "place");
	lua_gettable(L, -2);
	s->place = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "skill_mod");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->skill_mod = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "thn");
	lua_gettable(L, -2);
	s->thn = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "srh");
	lua_gettable(L, -2);
	s->srh = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "luck");
	lua_gettable(L, -2);
	s->luck = (char)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "f_b_ht");
	lua_gettable(L, -2);
	s->f_b_ht = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "stl");
	lua_gettable(L, -2);
	s->stl = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "dev");
	lua_gettable(L, -2);
	s->dev = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "fos");
	lua_gettable(L, -2);
	s->fos = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "desc");
	lua_gettable(L, -2);
	s->desc = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "body_parts");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->body_parts = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "dis");
	lua_gettable(L, -2);
	s->dis = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "load_script");
	lua_gettable(L, -2);
	s->load_script = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "adj");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->adj = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "oflags");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < PY_MAX_LEVEL + 1; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->oflags[i] = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "m_age");
	lua_gettable(L, -2);
	s->m_age = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "exp");
	lua_gettable(L, -2);
	s->exp = (u16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "f_m_wt");
	lua_gettable(L, -2);
	s->f_m_wt = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "mana");
	lua_gettable(L, -2);
	s->mana = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "abilities");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->abilities = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "sav");
	lua_gettable(L, -2);
	s->sav = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "blow_wgt");
	lua_gettable(L, -2);
	s->blow_wgt = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "f_m_ht");
	lua_gettable(L, -2);
	s->f_m_ht = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "f_b_wt");
	lua_gettable(L, -2);
	s->f_b_wt = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "flags");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->flags = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "m_m_wt");
	lua_gettable(L, -2);
	s->m_m_wt = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "m_m_ht");
	lua_gettable(L, -2);
	s->m_m_ht = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "b_age");
	lua_gettable(L, -2);
	s->b_age = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "m_b_ht");
	lua_gettable(L, -2);
	s->m_b_ht = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "type");
	lua_gettable(L, -2);
	s->type = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "powers");
	lua_gettable(L, -2);
	/* Indexed table */
	for (i = 0; i < 4; i++)
	{
		lua_pushnumber(L, i + 1);
		lua_gettable(L, -2);
		s->powers[i] = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	}
	lua_pop(L, 1);
	lua_pushstring(L, "choice");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->choice = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "id");
	lua_gettable(L, -2);
	s->id = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "blow_num");
	lua_gettable(L, -2);
	s->blow_num = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "skill_base");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->skill_base = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "mhp");
	lua_gettable(L, -2);
	s->mhp = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "objects");
	lua_gettable(L, -2);
	{ flags_type *f = (flags_type*)lua_touserdata(L, -1); s->objects = *f; VOID_FREE(f, flags_type); } lua_pop(L, 1);
	lua_pushstring(L, "infra");
	lua_gettable(L, -2);
	s->infra = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "extra_blows");
	lua_gettable(L, -2);
	s->extra_blows = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "thb");
	lua_gettable(L, -2);
	s->thb = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "m_b_wt");
	lua_gettable(L, -2);
	s->m_b_wt = (byte)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "chart");
	lua_gettable(L, -2);
	s->chart = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	lua_pushstring(L, "blow_mul");
	lua_gettable(L, -2);
	s->blow_mul = (s16b)lua_tonumber(L, -1); lua_pop(L, 1);
	lua_pushstring(L, "title");
	lua_gettable(L, -2);
	s->title = (cptr)string_make(lua_tostring(L, -1)); lua_pop(L, 1);
	return 0;
}
static int cache_wrap_make_player_descriptor(lua_State *L)
{
	max_dp_idx = lua_tonumber(L, -1); lua_pop(L, 1);
	C_MAKE(descriptor_info, max_dp_idx, player_descriptor);
	return 0;
}
errr init_descriptor_info(void)
{
	PHYSFS_file *fff = NULL;
	s32b i;
	bool test = must_reload_cache("player/descriptors.lua", "player/descriptors.raw");

	if (test)
	{
		/* Clear the functions registry of this file */
		exec_lua("__functions_registry[__info_cache.descriptor_info] = {}");

				
		/* Load the data */
		tome_dofile_anywhere(TENGINE_DIR_DATA, "player/descriptors.lua", TRUE, FALSE);

		/* Finish it */
		exec_lua(
			"make_cache_player_descriptor(__descriptor_num)\n"
			"for i = 1, getn(__descriptor_info.data) do load_cache_player_descriptor(__descriptor_info.data[i]) end\n"
			"__descriptor_info.data = {}"
		);

		/* Write the cache if requested */
		if (tome_write_raw_files)
		{
			fff = open_raw_cache("player/descriptors.raw", "wb");
			do_u16b(&max_dp_idx, LS_SAVE);
			for (i = 0; i < max_dp_idx; i++)
				cache_loadsave_player_descriptor(&(descriptor_info[i]), LS_SAVE);
		}
	}
	else
	{
		/* Load the cache */
		fff = open_raw_cache("player/descriptors.raw", "rb");
		do_u16b(&max_dp_idx, LS_LOAD);
		C_MAKE(descriptor_info, max_dp_idx, player_descriptor);
		for (i = 0; i < max_dp_idx; i++)
		{
			/* Load it */
			cache_loadsave_player_descriptor(&(descriptor_info[i]), LS_LOAD);
			/* Execute the needed script */
			exec_lua(descriptor_info[i].load_script);
		}
		/* Must set it for possible patch additions */
		exec_lua(format("__descriptor_num = %d", i));
	}
	if (fff != NULL) my_fclose(fff);

	/* Success */
	return (0);
}
errr load_functions_registry()
{
	PHYSFS_file *fff;
	s32b i;

	/* Load the cache */
	fff = open_raw_cache("registry.raw", "rb");
	if (fff != NULL)
	{
		lua_getglobal(L, "__functions_registry");
		for (i = 1; i <= 18; i++)
		{
			s32b j;
			s32b nb_ref;

			do_s32b(&nb_ref, LS_LOAD);

			lua_pushnumber(L, i);
			lua_gettable(L, -2);
			for (j = 0; j < nb_ref; j++)
			{
				s32b z;
				s32b ref;
				s32b size;
				char *buf;

				do_s32b(&ref, LS_LOAD);
				do_s32b(&size, LS_LOAD);
				C_MAKE(buf, size, char);
				for (z = 0; z < size; z++)
					do_char(&buf[z], LS_LOAD);

				lua_pushnumber(L, ref);
				lua_loadbuffer(L, buf, size, "(info file bytecode loaded)");
				lua_settable(L, -3);

				VOID_C_FREE(buf, size, char);
			}
			lua_pop(L, 1);
		}
		lua_pop(L, 1);
		my_fclose(fff);
	}

	/* Success */
	return (0);
}

extern char *luaU_dumpchunk_buffer(const Proto* Main, size_t *len);
extern Proto* lua_toluafunction (lua_State *L, s32b index);
errr save_functions_registry()
{
	PHYSFS_file *fff;
	s32b i;

	/* Do we actaully need to save it? */
	if (!has_reloaded_some) return 0;

	/* Load the cache */
	fff = open_raw_cache("registry.raw", "wb");
	if (fff == NULL) return 1;

	lua_getglobal(L, "__functions_registry");
	for (i = 1; i <= 18; i++)
	{
		s32b ref;
		s32b nb_ref;
		s32b real_count = 0;
		s32b j;

		/* Get the table */
		lua_pushnumber(L, i);
		lua_gettable(L, -2);

		/* Get the size, and iterate */
		nb_ref = lua_getn(L, -1);

		/* Count the exact number to be saved */
		for (j = 0; j <= nb_ref; j++)
		{
			lua_rawgeti(L, -1, j);
			if (lua_isfunction(L, -1)) real_count++;
			lua_pop(L, 1);
		}

		do_s32b(&real_count, LS_SAVE);

		for (ref = 0; ref <= nb_ref; ref++)
		{
			s32b z;
			s32b size;

			lua_rawgeti(L, -1, ref);

			if (lua_isfunction(L, -1))
			{
				Proto *l;
				char *buf;
				size_t len;

				l = lua_toluafunction(L, -1);
				buf = luaU_dumpchunk_buffer(l, &len);

				size = len;
				do_s32b(&ref, LS_SAVE);
				do_s32b(&size, LS_SAVE);
				for (z = 0; z < size; z++)
					do_char(&buf[z], LS_SAVE);

				VOID_C_FREE(buf, len, char);
			}
			lua_pop(L, 1);
		}
		lua_pop(L, 1);
	}
	lua_pop(L, 1);
	my_fclose(fff);

	/* Success */
	return (0);
}

static const struct luaL_reg cache_wrappers_lib[] =
{
	{"load_cache_ability_type", cache_wrap_ability_type},
	{"make_cache_ability_type", cache_wrap_make_ability_type},
	{"load_cache_object_kind", cache_wrap_object_kind},
	{"make_cache_object_kind", cache_wrap_make_object_kind},
	{"load_cache_owner_type", cache_wrap_owner_type},
	{"make_cache_owner_type", cache_wrap_make_owner_type},
	{"load_cache_store_action_type", cache_wrap_store_action_type},
	{"make_cache_store_action_type", cache_wrap_make_store_action_type},
	{"load_cache_store_info_type", cache_wrap_store_info_type},
	{"make_cache_store_info_type", cache_wrap_make_store_info_type},
	{"load_cache_skill_type", cache_wrap_skill_type},
	{"make_cache_skill_type", cache_wrap_make_skill_type},
	{"load_cache_monster_race", cache_wrap_monster_race},
	{"make_cache_monster_race", cache_wrap_make_monster_race},
	{"load_cache_rule_type", cache_wrap_rule_type},
	{"load_cache_dungeon_info_type", cache_wrap_dungeon_info_type},
	{"make_cache_dungeon_info_type", cache_wrap_make_dungeon_info_type},
	{"load_cache_feature_type", cache_wrap_feature_type},
	{"make_cache_feature_type", cache_wrap_make_feature_type},
	{"load_cache_player_descriptor", cache_wrap_player_descriptor},
	{"make_cache_player_descriptor", cache_wrap_make_player_descriptor},
	{"load_cache_vault_type", cache_wrap_vault_type},
	{"make_cache_vault_type", cache_wrap_make_vault_type},
	{"load_cache___set_type_aux", cache_wrap___set_type_aux},
	{"load_cache_set_type", cache_wrap_set_type},
	{"make_cache_set_type", cache_wrap_make_set_type},
	{"load_cache_monster_ego", cache_wrap_monster_ego},
	{"make_cache_monster_ego", cache_wrap_make_monster_ego},
	{"load_cache_ego_item_type", cache_wrap_ego_item_type},
	{"make_cache_ego_item_type", cache_wrap_make_ego_item_type},
	{"load_cache_artifact_type", cache_wrap_artifact_type},
	{"make_cache_artifact_type", cache_wrap_make_artifact_type},
	{"load_cache_wilderness_type_info", cache_wrap_wilderness_type_info},
	{"make_cache_wilderness_type_info", cache_wrap_make_wilderness_type_info},
	{"load_cache_randart_part_type", cache_wrap_randart_part_type},
	{"make_cache_randart_part_type", cache_wrap_make_randart_part_type},
};

void load_cache_wrappers()
{
	luaL_openl(L, cache_wrappers_lib);

	lua_newtable(L);
	lua_pushstring(L, "ra_info"); lua_pushnumber(L, 1); lua_settable(L, -3);
	lua_pushstring(L, "f_info"); lua_pushnumber(L, 2); lua_settable(L, -3);
	lua_pushstring(L, "wf_info"); lua_pushnumber(L, 3); lua_settable(L, -3);
	lua_pushstring(L, "s_info"); lua_pushnumber(L, 4); lua_settable(L, -3);
	lua_pushstring(L, "array_name"); lua_pushnumber(L, 5); lua_settable(L, -3);
	lua_pushstring(L, "a_info"); lua_pushnumber(L, 6); lua_settable(L, -3);
	lua_pushstring(L, "d_info"); lua_pushnumber(L, 7); lua_settable(L, -3);
	lua_pushstring(L, "v_info"); lua_pushnumber(L, 8); lua_settable(L, -3);
	lua_pushstring(L, "st_info"); lua_pushnumber(L, 9); lua_settable(L, -3);
	lua_pushstring(L, "ba_info"); lua_pushnumber(L, 10); lua_settable(L, -3);
	lua_pushstring(L, "re_info"); lua_pushnumber(L, 11); lua_settable(L, -3);
	lua_pushstring(L, "e_info"); lua_pushnumber(L, 12); lua_settable(L, -3);
	lua_pushstring(L, "r_info"); lua_pushnumber(L, 13); lua_settable(L, -3);
	lua_pushstring(L, "set_info"); lua_pushnumber(L, 14); lua_settable(L, -3);
	lua_pushstring(L, "k_info"); lua_pushnumber(L, 15); lua_settable(L, -3);
	lua_pushstring(L, "ab_info"); lua_pushnumber(L, 16); lua_settable(L, -3);
	lua_pushstring(L, "ow_info"); lua_pushnumber(L, 17); lua_settable(L, -3);
	lua_pushstring(L, "descriptor_info"); lua_pushnumber(L, 18); lua_settable(L, -3);
	lua_setglobal(L, "__info_cache");

	lua_newtable(L);
	lua_pushnumber(L, 1); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 2); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 3); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 4); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 5); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 6); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 7); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 8); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 9); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 10); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 11); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 12); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 13); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 14); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 15); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 16); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 17); lua_newtable(L); lua_settable(L, -3);
	lua_pushnumber(L, 18); lua_newtable(L); lua_settable(L, -3);
	lua_setglobal(L, "__functions_registry");
}
